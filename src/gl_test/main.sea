
fn main() {
    open_window();
    set_vsync(true); // NB setting to false will make the screen flash crazily

    let r = 0.0;
    let up = true;
    
    for {
        if up {
            r += 0.01;
            if r > 1.0 { up = false; }
        } else {
            r -= 0.01;
            if r < 0.0 { up = true; }
        }

        glClearColor(r, 1.0, 0.2 + (1.0 - r)*0.8, 1.0);
        glClear(u32(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));
        swap_buffers();
    }

    Sleep(1000);

    close_window();
    ExitProcess(0);
}

let wgl_swap_function: wglSwapIntervalEXT_Type;
let window_handle: Handle;
let gl_context: Handle;
let device_context: Handle;

fn open_window() {
    print("Creating window and initializing OpenGL\n");

    let class_name  = "help im trapped in a window class factory";
    let window_name = "Sea window test";

    let instance = GetModuleHandleA(null);

    let window_class_description = Window_Class {
        style: 32, // CS_OWNDC
        window_procedure: &event_callback,
        instance: instance,
        class_name: class_name.data,
    };
    let window_class = RegisterClassA(&window_class_description);
    assert(window_class != 0, "Failed to register window class");

    window_handle = CreateWindowExA(
        0, class_name.data, window_name.data,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        null, null, instance, null
    );
    assert(window_handle != null, "Couldn't open window");

    device_context = GetDC(window_handle);
    let pixel_format_description = Pixel_Format_Descriptor {
        size: u16(size_of(Pixel_Format_Descriptor)),
        version: 1,
        flags: PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
        pixel_type: PFD_TYPE_RGBA,
        color_bits: 24,
        alpha_bits: 8,
        layer_type: PFD_MAIN_PLANE,
    };
    let i = ChoosePixelFormat(device_context, &pixel_format_description);
    assert(SetPixelFormat(device_context, i, &pixel_format_description) != 0, "Couldn't set pixel format");

    let gl32_lib = LoadLibraryA("opengl32.dll".data);
    assert(gl32_lib != null, "Couldn't load opengl32.dll");

    let legacy_gl_context = wglCreateContext(device_context);
    wglMakeCurrent(device_context, legacy_gl_context);

    // NB this is only the subset of extensions I care about
    enum WGL_Extensions {
        WGL_ARB_create_context,
        WGL_ARB_create_context_profile,
        WGL_EXT_swap_control
    }
    let has_extensions: [enum_length(WGL_Extensions)]bool;

    {
        let wglGetExtensionsStringARB = cast(wglGetExtensionsStringARB_Type, get_gl_proc_address(gl32_lib, "wglGetExtensionsStringARB".data));
        assert(wglGetExtensionsStringARB != null, "WGL_ARB_extensions_string is not supported");
        let extensions = wglGetExtensionsStringARB(device_context);

        let substring = extensions;
        let length = 0;
        for (*extensions != 0) {
            if (*extensions == ' ') {
                let string = String { substring, length };

                for e : 0..enum_length(WGL_Extensions) {
                    let extension_name = enum_member_name(cast(WGL_Extensions, e));
                    if string_cmp(extension_name, string) {
                        has_extensions[e] = true;
                    }
                }

                for (*extensions == ' ') { extensions += 1; }

                substring = extensions;
                length = 0;
            } else {
                extensions += 1;
                length += 1;
            }
        }

        print("Detected GL extensions: ");
        for f : 0..enum_length(WGL_Extensions) {
            if (has_extensions[f]) {
                if f > 0 { print(", "); }
                print(enum_member_name(cast(WGL_Extensions, f)));
            }
        }
        print("\n");
    }

    assert(
        has_extensions[WGL_Extensions::WGL_ARB_create_context] && has_extensions[WGL_Extensions::WGL_ARB_create_context_profile],
        "Missing extensions WGL_ARB_create_context or WGL_ARB_create_context_profile",
    );
    let wglCreateContextAttribsARB = cast(wglCreateContextAttribsARB_Type, get_gl_proc_address(gl32_lib, "wglCreateContextAttribsARB".data));

    let context_attributes = [9]i32 {
        WGL_CONTEXT_MAJOR_VERSION_ARB, 3,
        WGL_CONTEXT_MINOR_VERSION_ARB, 3,
        WGL_CONTEXT_FLAGS_ARB, 0,
        WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
        0,
    };
    gl_context = wglCreateContextAttribsARB(device_context, null, &context_attributes);
    assert(gl_context != null, "Could not create modern GL context.");

    wglDeleteContext(legacy_gl_context);
    wglMakeCurrent(device_context, gl_context);

    wgl_swap_function = null;
    if has_extensions[WGL_Extensions::WGL_EXT_swap_control] {
        wgl_swap_function = cast(wglSwapIntervalEXT_Type, get_gl_proc_address(gl32_lib, "wglSwapIntervalEXT".data));
        assert(wgl_swap_function != null, "No wglSwapIntervalEXT, even though WGL_EXT_swap_control is supported");
    }

    load_gl(gl32_lib);

    print("Showing window!\n");
    ShowWindow(window_handle, SW_SHOW);
}

fn close_window() {
    wglDeleteContext(gl_context);
    DestroyWindow(window_handle);
}

fn swap_buffers() {
    SwapBuffers(device_context);
}

fn event_callback(window: Handle, message: u32, w: u64, l: i64) -> i64 {
    // TODO
    return DefWindowProcA(window, message, w, l);
}


fn set_vsync(vsync: bool) {
    if wgl_swap_function != null {
        wgl_swap_function(vsync? 1 : 0);
    }
}

typedef Handle = *void;
typedef Atom = u16;
typedef Window_Procedure = *fn(window: Handle, a: u32, b: u64, c: i64) -> i64;

struct Window_Class {
    style: u32;
    window_procedure: Window_Procedure;
    cbClsExtra: i32;
    cbWndExtra: i32;
    instance: Handle;
    icon: Handle;
    cursor: Handle;
    background: Handle;
    menu_name: *u8;
    class_name: *u8;
}

struct Pixel_Format_Descriptor {
    size: u16;
    version: u16;
    flags: u32;
    pixel_type: u8;
    color_bits: u8;

    red_bits,   red_shift: u8;
    green_bits, green_shift: u8;
    blue_bits,  blue_shift: u8;
    alpha_bits, alpha_shift: u8;

    accum_bits: u8;
    accum_red_bits: u8;
    accum_green_bits: u8;
    accum_blue_bits: u8;
    accum_alpha_bits: u8;

    depth_bits: u8;
    stencil_bits: u8;

    aux_buffers: u8;
    layer_type: u8;
    reserved: u8;
    layer_mask: u32;
    visible_mask: u32;
    damage_mask: u32;
}

extern "kernel32.lib" {
    fn ExitProcess(exit_code: u32);
    fn GetStdHandle(key: u32) -> u64;
    fn WriteFile(file: u64, buffer: *u8, length: u32, written: *u32, overlapped: *void);
    fn GetProcessHeap() -> u64;
    fn HeapAlloc(heap: u64, flags: u32, bytes: u64) -> *void;
    fn GetModuleHandleA(name: *u8) -> Handle;
    fn LoadLibraryA(name: *u8) -> Handle;
    fn GetProcAddress(library: Handle, name: *u8) -> *fn();
    fn Sleep(millis: u32);
}

extern "user32.lib" {
    fn RegisterClassA(class: *Window_Class) -> Atom;
    fn CreateWindowExA(
        ex_style: u32,
        class_name, window_name: *u8,
        style: u32,
        x, y, width, height: i32,
        parent, menu, instance: Handle,
        param: *void,
    ) -> Handle;
    fn GetDC(window: Handle) -> Handle;
    fn DefWindowProcA(window: Handle, msg: u32, w: u64, l: i64) -> i64;
    fn ShowWindow(window: Handle, cmd: i32) -> i32;
    fn DestroyWindow(window: Handle) -> i32;
}

extern "gdi32.lib" {
    fn ChoosePixelFormat(device_context: Handle, pfd: *Pixel_Format_Descriptor) -> i32;
    fn SetPixelFormat(device_context: Handle, index: i32, pfd: *Pixel_Format_Descriptor) -> i32;
    fn SwapBuffers(device_context: Handle) -> i32;
}

extern "opengl32.lib" {
    fn wglCreateContext(device_context: Handle) -> Handle;
    fn wglDeleteContext(gl_context: Handle) -> i32;
    fn wglMakeCurrent(device_context: Handle, gl_context: Handle) -> i32;
    fn wglGetProcAddress(name: *u8) -> *fn();
}

typedef wglGetExtensionsStringARB_Type  = *fn(device_context: Handle) -> *u8;
typedef wglCreateContextAttribsARB_Type = *fn(device_context: Handle, gl_context: Handle, attributes: *i32) -> Handle;
typedef wglSwapIntervalEXT_Type         = *fn(interval: i32) -> i32;

let WS_OVERLAPPED: u32   = 0x00000000;
let WS_CAPTION: u32      = 0x00C00000;
let WS_SYSMENU: u32      = 0x00080000;
let WS_THICKFRAME: u32   = 0x00040000;
let WS_MINIMIZEBOX: u32  = 0x00020000;
let WS_MAXIMIZEBOX: u32  = 0x00010000;
let WS_POPUP: u32        = 0x80000000;
let WS_CHILD: u32        = 0x40000000;
let WS_MINIMIZE: u32     = 0x20000000;
let WS_VISIBLE: u32      = 0x10000000;
let WS_DISABLED: u32     = 0x08000000;
let WS_CLIPSIBLINGS: u32 = 0x04000000;
let WS_CLIPCHILDREN: u32 = 0x02000000;
let WS_MAXIMIZE: u32     = 0x01000000;
let WS_BORDER: u32       = 0x00800000;
let WS_DLGFRAME: u32     = 0x00400000;
let WS_VSCROLL: u32      = 0x00200000;
let WS_HSCROLL: u32      = 0x00100000;
let WS_GROUP: u32        = 0x00020000;
let WS_TABSTOP: u32      = 0x00010000;
let WS_OVERLAPPEDWINDOW  = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;

let CW_USEDEFAULT: i32   = 0x80000000;

let PFD_DRAW_TO_WINDOW: u32 = 0x00000004;
let PFD_SUPPORT_OPENGL: u32 = 0x00000020;
let PFD_DOUBLEBUFFER: u32   = 0x00000001;
let PFD_TYPE_RGBA: u8       = 0;
let PFD_MAIN_PLANE: u8      = 0;

let WGL_CONTEXT_MAJOR_VERSION_ARB:    i32 = 0x2091;
let WGL_CONTEXT_MINOR_VERSION_ARB:    i32 = 0x2092;
let WGL_CONTEXT_FLAGS_ARB:            i32 = 0x2094;
let WGL_CONTEXT_PROFILE_MASK_ARB:     i32 = 0x9126;
let WGL_CONTEXT_CORE_PROFILE_BIT_ARB: i32 = 0x00000001;

let SW_HIDE: i32            = 0;
let SW_SHOWNORMAL: i32      = 1;
let SW_NORMAL: i32          = 1;
let SW_SHOWMINIMIZED: i32   = 2;
let SW_SHOWMAXIMIZED: i32   = 3;
let SW_MAXIMIZE: i32        = 3;
let SW_SHOWNOACTIVATE: i32  = 4;
let SW_SHOW: i32            = 5;
let SW_MINIMIZE: i32        = 6;
let SW_SHOWMINNOACTIVE: i32 = 7;
let SW_SHOWNA: i32          = 8;
let SW_RESTORE: i32         = 9;
let SW_SHOWDEFAULT: i32     = 10;
let SW_FORCEMINIMIZE: i32   = 11;

fn get_gl_proc_address(gl32_lib: Handle, name: *u8) -> *fn() {
    let address = wglGetProcAddress(name);

    let error_code = i64(address);
    if (error_code >= -1 && error_code <= 3) {
        address = GetProcAddress(gl32_lib, name);
    }

    return address;
}

fn string_cmp(a, b: String) -> bool {
    if a.length != b.length { return false; }

    for i : 0..a.length {
        if a[i] != b[i] {
            return false;
        }
    }

    return true;
}

let stdout_handle = GetStdHandle(u32(-11));
fn print(string: String) {
    let written: u32;
    WriteFile(stdout_handle, string.data, u32(string.length), &written, null);
}

fn assert(condition: bool, message: String) {
    if (!condition) {
        print("Assertion failed: ");
        print(message);
        print("\n");
        ExitProcess(-1);
    }
}

fn load_gl(gl32_lib: Handle) {
    // 0.0
    glCullFace               = load_gl_func(gl32_lib, "glCullFace".data);
    glFrontFace              = load_gl_func(gl32_lib, "glFrontFace".data);
    glHint                   = load_gl_func(gl32_lib, "glHint".data);
    glLineWidth              = load_gl_func(gl32_lib, "glLineWidth".data);
    glPointSize              = load_gl_func(gl32_lib, "glPointSize".data);
    glPolygonMode            = load_gl_func(gl32_lib, "glPolygonMode".data);
    glScissor                = load_gl_func(gl32_lib, "glScissor".data);
    glTexParameterf          = load_gl_func(gl32_lib, "glTexParameterf".data);
    glTexParameterfv         = load_gl_func(gl32_lib, "glTexParameterfv".data);
    glTexParameteri          = load_gl_func(gl32_lib, "glTexParameteri".data);
    glTexParameteriv         = load_gl_func(gl32_lib, "glTexParameteriv".data);
    glTexImage1D             = load_gl_func(gl32_lib, "glTexImage1D".data);
    glTexImage2D             = load_gl_func(gl32_lib, "glTexImage2D".data);
    glDrawBuffer             = load_gl_func(gl32_lib, "glDrawBuffer".data);
    glClear                  = load_gl_func(gl32_lib, "glClear".data);
    glClearColor             = load_gl_func(gl32_lib, "glClearColor".data);
    glClearStencil           = load_gl_func(gl32_lib, "glClearStencil".data);
    glClearDepth             = load_gl_func(gl32_lib, "glClearDepth".data);
    glStencilMask            = load_gl_func(gl32_lib, "glStencilMask".data);
    glColorMask              = load_gl_func(gl32_lib, "glColorMask".data);
    glDepthMask              = load_gl_func(gl32_lib, "glDepthMask".data);
    glDisable                = load_gl_func(gl32_lib, "glDisable".data);
    glEnable                 = load_gl_func(gl32_lib, "glEnable".data);
    glFinish                 = load_gl_func(gl32_lib, "glFinish".data);
    glFlush                  = load_gl_func(gl32_lib, "glFlush".data);
    glBlendFunc              = load_gl_func(gl32_lib, "glBlendFunc".data);
    glLogicOp                = load_gl_func(gl32_lib, "glLogicOp".data);
    glStencilFunc            = load_gl_func(gl32_lib, "glStencilFunc".data);
    glStencilOp              = load_gl_func(gl32_lib, "glStencilOp".data);
    glDepthFunc              = load_gl_func(gl32_lib, "glDepthFunc".data);
    glPixelStoref            = load_gl_func(gl32_lib, "glPixelStoref".data);
    glPixelStorei            = load_gl_func(gl32_lib, "glPixelStorei".data);
    glReadBuffer             = load_gl_func(gl32_lib, "glReadBuffer".data);
    glReadPixels             = load_gl_func(gl32_lib, "glReadPixels".data);
    glGetBooleanv            = load_gl_func(gl32_lib, "glGetBooleanv".data);
    glGetDoublev             = load_gl_func(gl32_lib, "glGetDoublev".data);
    glGetError               = load_gl_func(gl32_lib, "glGetError".data);
    glGetFloatv              = load_gl_func(gl32_lib, "glGetFloatv".data);
    glGetIntegerv            = load_gl_func(gl32_lib, "glGetIntegerv".data);
    glGetString              = load_gl_func(gl32_lib, "glGetString".data);
    glGetTexImage            = load_gl_func(gl32_lib, "glGetTexImage".data);
    glGetTexParameterfv      = load_gl_func(gl32_lib, "glGetTexParameterfv".data);
    glGetTexParameteriv      = load_gl_func(gl32_lib, "glGetTexParameteriv".data);
    glGetTexLevelParameterfv = load_gl_func(gl32_lib, "glGetTexLevelParameterfv".data);
    glGetTexLevelParameteriv = load_gl_func(gl32_lib, "glGetTexLevelParameteriv".data);
    glIsEnabled              = load_gl_func(gl32_lib, "glIsEnabled".data);
    glDepthRange             = load_gl_func(gl32_lib, "glDepthRange".data);
    glViewport               = load_gl_func(gl32_lib, "glViewport".data);

    // 1.1
    glDrawArrays        = load_gl_func(gl32_lib, "glDrawArrays".data);
    glDrawElements      = load_gl_func(gl32_lib, "glDrawElements".data);
    glPolygonOffset     = load_gl_func(gl32_lib, "glPolygonOffset".data);
    glCopyTexImage1D    = load_gl_func(gl32_lib, "glCopyTexImage1D".data);
    glCopyTexImage2D    = load_gl_func(gl32_lib, "glCopyTexImage2D".data);
    glCopyTexSubImage1D = load_gl_func(gl32_lib, "glCopyTexSubImage1D".data);
    glCopyTexSubImage2D = load_gl_func(gl32_lib, "glCopyTexSubImage2D".data);
    glTexSubImage1D     = load_gl_func(gl32_lib, "glTexSubImage1D".data);
    glTexSubImage2D     = load_gl_func(gl32_lib, "glTexSubImage2D".data);
    glBindTexture       = load_gl_func(gl32_lib, "glBindTexture".data);
    glDeleteTextures    = load_gl_func(gl32_lib, "glDeleteTextures".data);
    glGenTextures       = load_gl_func(gl32_lib, "glGenTextures".data);
    glIsTexture         = load_gl_func(gl32_lib, "glIsTexture".data);

    // 1.2
    glDrawRangeElements = load_gl_func(gl32_lib, "glDrawRangeElements".data);
    glTexImage3D        = load_gl_func(gl32_lib, "glTexImage3D".data);
    glTexSubImage3D     = load_gl_func(gl32_lib, "glTexSubImage3D".data);
    glCopyTexSubImage3D = load_gl_func(gl32_lib, "glCopyTexSubImage3D".data);

    // 1.3
    glActiveTexture           = load_gl_func(gl32_lib, "glActiveTexture".data);
    glSampleCoverage          = load_gl_func(gl32_lib, "glSampleCoverage".data);
    glCompressedTexImage3D    = load_gl_func(gl32_lib, "glCompressedTexImage3D".data);
    glCompressedTexImage2D    = load_gl_func(gl32_lib, "glCompressedTexImage2D".data);
    glCompressedTexImage1D    = load_gl_func(gl32_lib, "glCompressedTexImage1D".data);
    glCompressedTexSubImage3D = load_gl_func(gl32_lib, "glCompressedTexSubImage3D".data);
    glCompressedTexSubImage2D = load_gl_func(gl32_lib, "glCompressedTexSubImage2D".data);
    glCompressedTexSubImage1D = load_gl_func(gl32_lib, "glCompressedTexSubImage1D".data);
    glGetCompressedTexImage   = load_gl_func(gl32_lib, "glGetCompressedTexImage".data);

    // 1.4
    glBlendFuncSeparate = load_gl_func(gl32_lib, "glBlendFuncSeparate".data);
    glMultiDrawArrays   = load_gl_func(gl32_lib, "glMultiDrawArrays".data);
    glMultiDrawElements = load_gl_func(gl32_lib, "glMultiDrawElements".data);
    glPointParameterf   = load_gl_func(gl32_lib, "glPointParameterf".data);
    glPointParameterfv  = load_gl_func(gl32_lib, "glPointParameterfv".data);
    glPointParameteri   = load_gl_func(gl32_lib, "glPointParameteri".data);
    glPointParameteriv  = load_gl_func(gl32_lib, "glPointParameteriv".data);
    glBlendColor        = load_gl_func(gl32_lib, "glBlendColor".data);
    glBlendEquation     = load_gl_func(gl32_lib, "glBlendEquation".data);

    // 1.5
    glGenQueries           = load_gl_func(gl32_lib, "glGenQueries".data);
    glDeleteQueries        = load_gl_func(gl32_lib, "glDeleteQueries".data);
    glIsQuery              = load_gl_func(gl32_lib, "glIsQuery".data);
    glBeginQuery           = load_gl_func(gl32_lib, "glBeginQuery".data);
    glEndQuery             = load_gl_func(gl32_lib, "glEndQuery".data);
    glGetQueryiv           = load_gl_func(gl32_lib, "glGetQueryiv".data);
    glGetQueryObjectiv     = load_gl_func(gl32_lib, "glGetQueryObjectiv".data);
    glGetQueryObjectuiv    = load_gl_func(gl32_lib, "glGetQueryObjectuiv".data);
    glBindBuffer           = load_gl_func(gl32_lib, "glBindBuffer".data);
    glDeleteBuffers        = load_gl_func(gl32_lib, "glDeleteBuffers".data);
    glGenBuffers           = load_gl_func(gl32_lib, "glGenBuffers".data);
    glIsBuffer             = load_gl_func(gl32_lib, "glIsBuffer".data);
    glBufferData           = load_gl_func(gl32_lib, "glBufferData".data);
    glBufferSubData        = load_gl_func(gl32_lib, "glBufferSubData".data);
    glGetBufferSubData     = load_gl_func(gl32_lib, "glGetBufferSubData".data);
    glMapBuffer            = load_gl_func(gl32_lib, "glMapBuffer".data);
    glUnmapBuffer          = load_gl_func(gl32_lib, "glUnmapBuffer".data);
    glGetBufferParameteriv = load_gl_func(gl32_lib, "glGetBufferParameteriv".data);
    glGetBufferPointerv    = load_gl_func(gl32_lib, "glGetBufferPointerv".data);

    // 2.0
    glBlendEquationSeparate    = load_gl_func(gl32_lib, "glBlendEquationSeparate".data);
    glDrawBuffers              = load_gl_func(gl32_lib, "glDrawBuffers".data);
    glStencilOpSeparate        = load_gl_func(gl32_lib, "glStencilOpSeparate".data);
    glStencilFuncSeparate      = load_gl_func(gl32_lib, "glStencilFuncSeparate".data);
    glStencilMaskSeparate      = load_gl_func(gl32_lib, "glStencilMaskSeparate".data);
    glAttachShader             = load_gl_func(gl32_lib, "glAttachShader".data);
    glBindAttribLocation       = load_gl_func(gl32_lib, "glBindAttribLocation".data);
    glCompileShader            = load_gl_func(gl32_lib, "glCompileShader".data);
    glCreateProgram            = load_gl_func(gl32_lib, "glCreateProgram".data);
    glCreateShader             = load_gl_func(gl32_lib, "glCreateShader".data);
    glDeleteProgram            = load_gl_func(gl32_lib, "glDeleteProgram".data);
    glDeleteShader             = load_gl_func(gl32_lib, "glDeleteShader".data);
    glDetachShader             = load_gl_func(gl32_lib, "glDetachShader".data);
    glDisableVertexAttribArray = load_gl_func(gl32_lib, "glDisableVertexAttribArray".data);
    glEnableVertexAttribArray  = load_gl_func(gl32_lib, "glEnableVertexAttribArray".data);
    glGetActiveAttrib          = load_gl_func(gl32_lib, "glGetActiveAttrib".data);
    glGetActiveUniform         = load_gl_func(gl32_lib, "glGetActiveUniform".data);
    glGetAttachedShaders       = load_gl_func(gl32_lib, "glGetAttachedShaders".data);
    glGetAttribLocation        = load_gl_func(gl32_lib, "glGetAttribLocation".data);
    glGetProgramiv             = load_gl_func(gl32_lib, "glGetProgramiv".data);
    glGetProgramInfoLog        = load_gl_func(gl32_lib, "glGetProgramInfoLog".data);
    glGetShaderiv              = load_gl_func(gl32_lib, "glGetShaderiv".data);
    glGetShaderInfoLog         = load_gl_func(gl32_lib, "glGetShaderInfoLog".data);
    glGetShaderSource          = load_gl_func(gl32_lib, "glGetShaderSource".data);
    glGetUniformLocation       = load_gl_func(gl32_lib, "glGetUniformLocation".data);
    glGetUniformfv             = load_gl_func(gl32_lib, "glGetUniformfv".data);
    glGetUniformiv             = load_gl_func(gl32_lib, "glGetUniformiv".data);
    glGetVertexAttribdv        = load_gl_func(gl32_lib, "glGetVertexAttribdv".data);
    glGetVertexAttribfv        = load_gl_func(gl32_lib, "glGetVertexAttribfv".data);
    glGetVertexAttribiv        = load_gl_func(gl32_lib, "glGetVertexAttribiv".data);
    glGetVertexAttribPointerv  = load_gl_func(gl32_lib, "glGetVertexAttribPointerv".data);
    glIsProgram                = load_gl_func(gl32_lib, "glIsProgram".data);
    glIsShader                 = load_gl_func(gl32_lib, "glIsShader".data);
    glLinkProgram              = load_gl_func(gl32_lib, "glLinkProgram".data);
    glShaderSource             = load_gl_func(gl32_lib, "glShaderSource".data);
    glUseProgram               = load_gl_func(gl32_lib, "glUseProgram".data);
    glUniform1f                = load_gl_func(gl32_lib, "glUniform1f".data);
    glUniform2f                = load_gl_func(gl32_lib, "glUniform2f".data);
    glUniform3f                = load_gl_func(gl32_lib, "glUniform3f".data);
    glUniform4f                = load_gl_func(gl32_lib, "glUniform4f".data);
    glUniform1i                = load_gl_func(gl32_lib, "glUniform1i".data);
    glUniform2i                = load_gl_func(gl32_lib, "glUniform2i".data);
    glUniform3i                = load_gl_func(gl32_lib, "glUniform3i".data);
    glUniform4i                = load_gl_func(gl32_lib, "glUniform4i".data);
    glUniform1fv               = load_gl_func(gl32_lib, "glUniform1fv".data);
    glUniform2fv               = load_gl_func(gl32_lib, "glUniform2fv".data);
    glUniform3fv               = load_gl_func(gl32_lib, "glUniform3fv".data);
    glUniform4fv               = load_gl_func(gl32_lib, "glUniform4fv".data);
    glUniform1iv               = load_gl_func(gl32_lib, "glUniform1iv".data);
    glUniform2iv               = load_gl_func(gl32_lib, "glUniform2iv".data);
    glUniform3iv               = load_gl_func(gl32_lib, "glUniform3iv".data);
    glUniform4iv               = load_gl_func(gl32_lib, "glUniform4iv".data);
    glUniformMatrix2fv         = load_gl_func(gl32_lib, "glUniformMatrix2fv".data);
    glUniformMatrix3fv         = load_gl_func(gl32_lib, "glUniformMatrix3fv".data);
    glUniformMatrix4fv         = load_gl_func(gl32_lib, "glUniformMatrix4fv".data);
    glValidateProgram          = load_gl_func(gl32_lib, "glValidateProgram".data);
    glVertexAttrib1d           = load_gl_func(gl32_lib, "glVertexAttrib1d".data);
    glVertexAttrib1dv          = load_gl_func(gl32_lib, "glVertexAttrib1dv".data);
    glVertexAttrib1f           = load_gl_func(gl32_lib, "glVertexAttrib1f".data);
    glVertexAttrib1fv          = load_gl_func(gl32_lib, "glVertexAttrib1fv".data);
    glVertexAttrib1s           = load_gl_func(gl32_lib, "glVertexAttrib1s".data);
    glVertexAttrib1sv          = load_gl_func(gl32_lib, "glVertexAttrib1sv".data);
    glVertexAttrib2d           = load_gl_func(gl32_lib, "glVertexAttrib2d".data);
    glVertexAttrib2dv          = load_gl_func(gl32_lib, "glVertexAttrib2dv".data);
    glVertexAttrib2f           = load_gl_func(gl32_lib, "glVertexAttrib2f".data);
    glVertexAttrib2fv          = load_gl_func(gl32_lib, "glVertexAttrib2fv".data);
    glVertexAttrib2s           = load_gl_func(gl32_lib, "glVertexAttrib2s".data);
    glVertexAttrib2sv          = load_gl_func(gl32_lib, "glVertexAttrib2sv".data);
    glVertexAttrib3d           = load_gl_func(gl32_lib, "glVertexAttrib3d".data);
    glVertexAttrib3dv          = load_gl_func(gl32_lib, "glVertexAttrib3dv".data);
    glVertexAttrib3f           = load_gl_func(gl32_lib, "glVertexAttrib3f".data);
    glVertexAttrib3fv          = load_gl_func(gl32_lib, "glVertexAttrib3fv".data);
    glVertexAttrib3s           = load_gl_func(gl32_lib, "glVertexAttrib3s".data);
    glVertexAttrib3sv          = load_gl_func(gl32_lib, "glVertexAttrib3sv".data);
    glVertexAttrib4Nbv         = load_gl_func(gl32_lib, "glVertexAttrib4Nbv".data);
    glVertexAttrib4Niv         = load_gl_func(gl32_lib, "glVertexAttrib4Niv".data);
    glVertexAttrib4Nsv         = load_gl_func(gl32_lib, "glVertexAttrib4Nsv".data);
    glVertexAttrib4Nub         = load_gl_func(gl32_lib, "glVertexAttrib4Nub".data);
    glVertexAttrib4Nubv        = load_gl_func(gl32_lib, "glVertexAttrib4Nubv".data);
    glVertexAttrib4Nuiv        = load_gl_func(gl32_lib, "glVertexAttrib4Nuiv".data);
    glVertexAttrib4Nusv        = load_gl_func(gl32_lib, "glVertexAttrib4Nusv".data);
    glVertexAttrib4bv          = load_gl_func(gl32_lib, "glVertexAttrib4bv".data);
    glVertexAttrib4d           = load_gl_func(gl32_lib, "glVertexAttrib4d".data);
    glVertexAttrib4dv          = load_gl_func(gl32_lib, "glVertexAttrib4dv".data);
    glVertexAttrib4f           = load_gl_func(gl32_lib, "glVertexAttrib4f".data);
    glVertexAttrib4fv          = load_gl_func(gl32_lib, "glVertexAttrib4fv".data);
    glVertexAttrib4iv          = load_gl_func(gl32_lib, "glVertexAttrib4iv".data);
    glVertexAttrib4s           = load_gl_func(gl32_lib, "glVertexAttrib4s".data);
    glVertexAttrib4sv          = load_gl_func(gl32_lib, "glVertexAttrib4sv".data);
    glVertexAttrib4ubv         = load_gl_func(gl32_lib, "glVertexAttrib4ubv".data);
    glVertexAttrib4uiv         = load_gl_func(gl32_lib, "glVertexAttrib4uiv".data);
    glVertexAttrib4usv         = load_gl_func(gl32_lib, "glVertexAttrib4usv".data);
    glVertexAttribPointer      = load_gl_func(gl32_lib, "glVertexAttribPointer".data);

    // 2.1
    glUniformMatrix2x3fv = load_gl_func(gl32_lib, "glUniformMatrix2x3fv".data);
    glUniformMatrix3x2fv = load_gl_func(gl32_lib, "glUniformMatrix3x2fv".data);
    glUniformMatrix2x4fv = load_gl_func(gl32_lib, "glUniformMatrix2x4fv".data);
    glUniformMatrix4x2fv = load_gl_func(gl32_lib, "glUniformMatrix4x2fv".data);
    glUniformMatrix3x4fv = load_gl_func(gl32_lib, "glUniformMatrix3x4fv".data);
    glUniformMatrix4x3fv = load_gl_func(gl32_lib, "glUniformMatrix4x3fv".data);

    // 3.0
    glColorMaski                          = load_gl_func(gl32_lib, "glColorMaski".data);
    glGetBooleani_v                       = load_gl_func(gl32_lib, "glGetBooleani_v".data);
    glGetIntegeri_v                       = load_gl_func(gl32_lib, "glGetIntegeri_v".data);
    glEnablei                             = load_gl_func(gl32_lib, "glEnablei".data);
    glDisablei                            = load_gl_func(gl32_lib, "glDisablei".data);
    glIsEnabledi                          = load_gl_func(gl32_lib, "glIsEnabledi".data);
    glBeginTransformFeedback              = load_gl_func(gl32_lib, "glBeginTransformFeedback".data);
    glEndTransformFeedback                = load_gl_func(gl32_lib, "glEndTransformFeedback".data);
    glBindBufferRange                     = load_gl_func(gl32_lib, "glBindBufferRange".data);
    glBindBufferBase                      = load_gl_func(gl32_lib, "glBindBufferBase".data);
    glTransformFeedbackVaryings           = load_gl_func(gl32_lib, "glTransformFeedbackVaryings".data);
    glGetTransformFeedbackVarying         = load_gl_func(gl32_lib, "glGetTransformFeedbackVarying".data);
    glClampColor                          = load_gl_func(gl32_lib, "glClampColor".data);
    glBeginConditionalRender              = load_gl_func(gl32_lib, "glBeginConditionalRender".data);
    glEndConditionalRender                = load_gl_func(gl32_lib, "glEndConditionalRender".data);
    glVertexAttribIPointer                = load_gl_func(gl32_lib, "glVertexAttribIPointer".data);
    glGetVertexAttribIiv                  = load_gl_func(gl32_lib, "glGetVertexAttribIiv".data);
    glGetVertexAttribIuiv                 = load_gl_func(gl32_lib, "glGetVertexAttribIuiv".data);
    glVertexAttribI1i                     = load_gl_func(gl32_lib, "glVertexAttribI1i".data);
    glVertexAttribI2i                     = load_gl_func(gl32_lib, "glVertexAttribI2i".data);
    glVertexAttribI3i                     = load_gl_func(gl32_lib, "glVertexAttribI3i".data);
    glVertexAttribI4i                     = load_gl_func(gl32_lib, "glVertexAttribI4i".data);
    glVertexAttribI1ui                    = load_gl_func(gl32_lib, "glVertexAttribI1ui".data);
    glVertexAttribI2ui                    = load_gl_func(gl32_lib, "glVertexAttribI2ui".data);
    glVertexAttribI3ui                    = load_gl_func(gl32_lib, "glVertexAttribI3ui".data);
    glVertexAttribI4ui                    = load_gl_func(gl32_lib, "glVertexAttribI4ui".data);
    glVertexAttribI1iv                    = load_gl_func(gl32_lib, "glVertexAttribI1iv".data);
    glVertexAttribI2iv                    = load_gl_func(gl32_lib, "glVertexAttribI2iv".data);
    glVertexAttribI3iv                    = load_gl_func(gl32_lib, "glVertexAttribI3iv".data);
    glVertexAttribI4iv                    = load_gl_func(gl32_lib, "glVertexAttribI4iv".data);
    glVertexAttribI1uiv                   = load_gl_func(gl32_lib, "glVertexAttribI1uiv".data);
    glVertexAttribI2uiv                   = load_gl_func(gl32_lib, "glVertexAttribI2uiv".data);
    glVertexAttribI3uiv                   = load_gl_func(gl32_lib, "glVertexAttribI3uiv".data);
    glVertexAttribI4uiv                   = load_gl_func(gl32_lib, "glVertexAttribI4uiv".data);
    glVertexAttribI4bv                    = load_gl_func(gl32_lib, "glVertexAttribI4bv".data);
    glVertexAttribI4sv                    = load_gl_func(gl32_lib, "glVertexAttribI4sv".data);
    glVertexAttribI4ubv                   = load_gl_func(gl32_lib, "glVertexAttribI4ubv".data);
    glVertexAttribI4usv                   = load_gl_func(gl32_lib, "glVertexAttribI4usv".data);
    glGetUniformuiv                       = load_gl_func(gl32_lib, "glGetUniformuiv".data);
    glBindFragDataLocation                = load_gl_func(gl32_lib, "glBindFragDataLocation".data);
    glGetFragDataLocation                 = load_gl_func(gl32_lib, "glGetFragDataLocation".data);
    glUniform1ui                          = load_gl_func(gl32_lib, "glUniform1ui".data);
    glUniform2ui                          = load_gl_func(gl32_lib, "glUniform2ui".data);
    glUniform3ui                          = load_gl_func(gl32_lib, "glUniform3ui".data);
    glUniform4ui                          = load_gl_func(gl32_lib, "glUniform4ui".data);
    glUniform1uiv                         = load_gl_func(gl32_lib, "glUniform1uiv".data);
    glUniform2uiv                         = load_gl_func(gl32_lib, "glUniform2uiv".data);
    glUniform3uiv                         = load_gl_func(gl32_lib, "glUniform3uiv".data);
    glUniform4uiv                         = load_gl_func(gl32_lib, "glUniform4uiv".data);
    glTexParameterIiv                     = load_gl_func(gl32_lib, "glTexParameterIiv".data);
    glTexParameterIuiv                    = load_gl_func(gl32_lib, "glTexParameterIuiv".data);
    glGetTexParameterIiv                  = load_gl_func(gl32_lib, "glGetTexParameterIiv".data);
    glGetTexParameterIuiv                 = load_gl_func(gl32_lib, "glGetTexParameterIuiv".data);
    glClearBufferiv                       = load_gl_func(gl32_lib, "glClearBufferiv".data);
    glClearBufferuiv                      = load_gl_func(gl32_lib, "glClearBufferuiv".data);
    glClearBufferfv                       = load_gl_func(gl32_lib, "glClearBufferfv".data);
    glClearBufferfi                       = load_gl_func(gl32_lib, "glClearBufferfi".data);
    glGetStringi                          = load_gl_func(gl32_lib, "glGetStringi".data);
    glIsRenderbuffer                      = load_gl_func(gl32_lib, "glIsRenderbuffer".data);
    glBindRenderbuffer                    = load_gl_func(gl32_lib, "glBindRenderbuffer".data);
    glDeleteRenderbuffers                 = load_gl_func(gl32_lib, "glDeleteRenderbuffers".data);
    glGenRenderbuffers                    = load_gl_func(gl32_lib, "glGenRenderbuffers".data);
    glRenderbufferStorage                 = load_gl_func(gl32_lib, "glRenderbufferStorage".data);
    glGetRenderbufferParameteriv          = load_gl_func(gl32_lib, "glGetRenderbufferParameteriv".data);
    glIsFramebuffer                       = load_gl_func(gl32_lib, "glIsFramebuffer".data);
    glBindFramebuffer                     = load_gl_func(gl32_lib, "glBindFramebuffer".data);
    glDeleteFramebuffers                  = load_gl_func(gl32_lib, "glDeleteFramebuffers".data);
    glGenFramebuffers                     = load_gl_func(gl32_lib, "glGenFramebuffers".data);
    glCheckFramebufferStatus              = load_gl_func(gl32_lib, "glCheckFramebufferStatus".data);
    glFramebufferTexture1D                = load_gl_func(gl32_lib, "glFramebufferTexture1D".data);
    glFramebufferTexture2D                = load_gl_func(gl32_lib, "glFramebufferTexture2D".data);
    glFramebufferTexture3D                = load_gl_func(gl32_lib, "glFramebufferTexture3D".data);
    glFramebufferRenderbuffer             = load_gl_func(gl32_lib, "glFramebufferRenderbuffer".data);
    glGetFramebufferAttachmentParameteriv = load_gl_func(gl32_lib, "glGetFramebufferAttachmentParameteriv".data);
    glGenerateMipmap                      = load_gl_func(gl32_lib, "glGenerateMipmap".data);
    glBlitFramebuffer                     = load_gl_func(gl32_lib, "glBlitFramebuffer".data);
    glRenderbufferStorageMultisample      = load_gl_func(gl32_lib, "glRenderbufferStorageMultisample".data);
    glFramebufferTextureLayer             = load_gl_func(gl32_lib, "glFramebufferTextureLayer".data);
    glMapBufferRange                      = load_gl_func(gl32_lib, "glMapBufferRange".data);
    glFlushMappedBufferRange              = load_gl_func(gl32_lib, "glFlushMappedBufferRange".data);
    glBindVertexArray                     = load_gl_func(gl32_lib, "glBindVertexArray".data);
    glDeleteVertexArrays                  = load_gl_func(gl32_lib, "glDeleteVertexArrays".data);
    glGenVertexArrays                     = load_gl_func(gl32_lib, "glGenVertexArrays".data);
    glIsVertexArray                       = load_gl_func(gl32_lib, "glIsVertexArray".data);

    // 3.1
    glDrawArraysInstanced       = load_gl_func(gl32_lib, "glDrawArraysInstanced".data);
    glDrawElementsInstanced     = load_gl_func(gl32_lib, "glDrawElementsInstanced".data);
    glTexBuffer                 = load_gl_func(gl32_lib, "glTexBuffer".data);
    glPrimitiveRestartIndex     = load_gl_func(gl32_lib, "glPrimitiveRestartIndex".data);
    glCopyBufferSubData         = load_gl_func(gl32_lib, "glCopyBufferSubData".data);
    glGetUniformIndices         = load_gl_func(gl32_lib, "glGetUniformIndices".data);
    glGetActiveUniformsiv       = load_gl_func(gl32_lib, "glGetActiveUniformsiv".data);
    glGetActiveUniformName      = load_gl_func(gl32_lib, "glGetActiveUniformName".data);
    glGetUniformBlockIndex      = load_gl_func(gl32_lib, "glGetUniformBlockIndex".data);
    glGetActiveUniformBlockiv   = load_gl_func(gl32_lib, "glGetActiveUniformBlockiv".data);
    glGetActiveUniformBlockName = load_gl_func(gl32_lib, "glGetActiveUniformBlockName".data);
    glUniformBlockBinding       = load_gl_func(gl32_lib, "glUniformBlockBinding".data);

    // 3.2
    glDrawElementsBaseVertex          = load_gl_func(gl32_lib, "glDrawElementsBaseVertex".data);
    glDrawRangeElementsBaseVertex     = load_gl_func(gl32_lib, "glDrawRangeElementsBaseVertex".data);
    glDrawElementsInstancedBaseVertex = load_gl_func(gl32_lib, "glDrawElementsInstancedBaseVertex".data);
    glMultiDrawElementsBaseVertex     = load_gl_func(gl32_lib, "glMultiDrawElementsBaseVertex".data);
    glProvokingVertex                 = load_gl_func(gl32_lib, "glProvokingVertex".data);
    glFenceSync                       = load_gl_func(gl32_lib, "glFenceSync".data);
    glIsSync                          = load_gl_func(gl32_lib, "glIsSync".data);
    glDeleteSync                      = load_gl_func(gl32_lib, "glDeleteSync".data);
    glClientWaitSync                  = load_gl_func(gl32_lib, "glClientWaitSync".data);
    glWaitSync                        = load_gl_func(gl32_lib, "glWaitSync".data);
    glGetInteger64v                   = load_gl_func(gl32_lib, "glGetInteger64v".data);
    glGetSynciv                       = load_gl_func(gl32_lib, "glGetSynciv".data);
    glGetInteger64i_v                 = load_gl_func(gl32_lib, "glGetInteger64i_v".data);
    glGetBufferParameteri64v          = load_gl_func(gl32_lib, "glGetBufferParameteri64v".data);
    glFramebufferTexture              = load_gl_func(gl32_lib, "glFramebufferTexture".data);
    glTexImage2DMultisample           = load_gl_func(gl32_lib, "glTexImage2DMultisample".data);
    glTexImage3DMultisample           = load_gl_func(gl32_lib, "glTexImage3DMultisample".data);
    glGetMultisamplefv                = load_gl_func(gl32_lib, "glGetMultisamplefv".data);
    glSampleMaski                     = load_gl_func(gl32_lib, "glSampleMaski".data);

    // 3.3
    glBindFragDataLocationIndexed = load_gl_func(gl32_lib, "glBindFragDataLocationIndexed".data);
    glGetFragDataIndex            = load_gl_func(gl32_lib, "glGetFragDataIndex".data);
    glGenSamplers                 = load_gl_func(gl32_lib, "glGenSamplers".data);
    glDeleteSamplers              = load_gl_func(gl32_lib, "glDeleteSamplers".data);
    glIsSampler                   = load_gl_func(gl32_lib, "glIsSampler".data);
    glBindSampler                 = load_gl_func(gl32_lib, "glBindSampler".data);
    glSamplerParameteri           = load_gl_func(gl32_lib, "glSamplerParameteri".data);
    glSamplerParameteriv          = load_gl_func(gl32_lib, "glSamplerParameteriv".data);
    glSamplerParameterf           = load_gl_func(gl32_lib, "glSamplerParameterf".data);
    glSamplerParameterfv          = load_gl_func(gl32_lib, "glSamplerParameterfv".data);
    glSamplerParameterIiv         = load_gl_func(gl32_lib, "glSamplerParameterIiv".data);
    glSamplerParameterIuiv        = load_gl_func(gl32_lib, "glSamplerParameterIuiv".data);
    glGetSamplerParameteriv       = load_gl_func(gl32_lib, "glGetSamplerParameteriv".data);
    glGetSamplerParameterIiv      = load_gl_func(gl32_lib, "glGetSamplerParameterIiv".data);
    glGetSamplerParameterfv       = load_gl_func(gl32_lib, "glGetSamplerParameterfv".data);
    glGetSamplerParameterIuiv     = load_gl_func(gl32_lib, "glGetSamplerParameterIuiv".data);
    glQueryCounter                = load_gl_func(gl32_lib, "glQueryCounter".data);
    glGetQueryObjecti64v          = load_gl_func(gl32_lib, "glGetQueryObjecti64v".data);
    glGetQueryObjectui64v         = load_gl_func(gl32_lib, "glGetQueryObjectui64v".data);
    glVertexAttribDivisor         = load_gl_func(gl32_lib, "glVertexAttribDivisor".data);
    glVertexAttribP1ui            = load_gl_func(gl32_lib, "glVertexAttribP1ui".data);
    glVertexAttribP1uiv           = load_gl_func(gl32_lib, "glVertexAttribP1uiv".data);
    glVertexAttribP2ui            = load_gl_func(gl32_lib, "glVertexAttribP2ui".data);
    glVertexAttribP2uiv           = load_gl_func(gl32_lib, "glVertexAttribP2uiv".data);
    glVertexAttribP3ui            = load_gl_func(gl32_lib, "glVertexAttribP3ui".data);
    glVertexAttribP3uiv           = load_gl_func(gl32_lib, "glVertexAttribP3uiv".data);
    glVertexAttribP4ui            = load_gl_func(gl32_lib, "glVertexAttribP4ui".data);
    glVertexAttribP4uiv           = load_gl_func(gl32_lib, "glVertexAttribP4uiv".data);
    glVertexP2ui                  = load_gl_func(gl32_lib, "glVertexP2ui".data);
    glVertexP2uiv                 = load_gl_func(gl32_lib, "glVertexP2uiv".data);
    glVertexP3ui                  = load_gl_func(gl32_lib, "glVertexP3ui".data);
    glVertexP3uiv                 = load_gl_func(gl32_lib, "glVertexP3uiv".data);
    glVertexP4ui                  = load_gl_func(gl32_lib, "glVertexP4ui".data);
    glVertexP4uiv                 = load_gl_func(gl32_lib, "glVertexP4uiv".data);
    glTexCoordP1ui                = load_gl_func(gl32_lib, "glTexCoordP1ui".data);
    glTexCoordP1uiv               = load_gl_func(gl32_lib, "glTexCoordP1uiv".data);
    glTexCoordP2ui                = load_gl_func(gl32_lib, "glTexCoordP2ui".data);
    glTexCoordP2uiv               = load_gl_func(gl32_lib, "glTexCoordP2uiv".data);
    glTexCoordP3ui                = load_gl_func(gl32_lib, "glTexCoordP3ui".data);
    glTexCoordP3uiv               = load_gl_func(gl32_lib, "glTexCoordP3uiv".data);
    glTexCoordP4ui                = load_gl_func(gl32_lib, "glTexCoordP4ui".data);
    glTexCoordP4uiv               = load_gl_func(gl32_lib, "glTexCoordP4uiv".data);
    glMultiTexCoordP1ui           = load_gl_func(gl32_lib, "glMultiTexCoordP1ui".data);
    glMultiTexCoordP1uiv          = load_gl_func(gl32_lib, "glMultiTexCoordP1uiv".data);
    glMultiTexCoordP2ui           = load_gl_func(gl32_lib, "glMultiTexCoordP2ui".data);
    glMultiTexCoordP2uiv          = load_gl_func(gl32_lib, "glMultiTexCoordP2uiv".data);
    glMultiTexCoordP3ui           = load_gl_func(gl32_lib, "glMultiTexCoordP3ui".data);
    glMultiTexCoordP3uiv          = load_gl_func(gl32_lib, "glMultiTexCoordP3uiv".data);
    glMultiTexCoordP4ui           = load_gl_func(gl32_lib, "glMultiTexCoordP4ui".data);
    glMultiTexCoordP4uiv          = load_gl_func(gl32_lib, "glMultiTexCoordP4uiv".data);
    glNormalP3ui                  = load_gl_func(gl32_lib, "glNormalP3ui".data);
    glNormalP3uiv                 = load_gl_func(gl32_lib, "glNormalP3uiv".data);
    glColorP3ui                   = load_gl_func(gl32_lib, "glColorP3ui".data);
    glColorP3uiv                  = load_gl_func(gl32_lib, "glColorP3uiv".data);
    glColorP4ui                   = load_gl_func(gl32_lib, "glColorP4ui".data);
    glColorP4uiv                  = load_gl_func(gl32_lib, "glColorP4uiv".data);
    glSecondaryColorP3ui          = load_gl_func(gl32_lib, "glSecondaryColorP3ui".data);
    glSecondaryColorP3uiv         = load_gl_func(gl32_lib, "glSecondaryColorP3uiv".data);
}

fn load_gl_func(gl32_lib: Handle, name: *u8) -> *void {
    return get_gl_proc_address(gl32_lib, name);
}

// 0.0
let glCullFace:               *fn(mode: u32);
let glFrontFace:              *fn(mode: u32);
let glHint:                   *fn(target: u32, mode: u32);
let glLineWidth:              *fn(width: f32);
let glPointSize:              *fn(size: f32);
let glPolygonMode:            *fn(face: u32, mode: u32);
let glScissor:                *fn(x: i32, y: i32, width: i32, height: i32);
let glTexParameterf:          *fn(target: u32, pname: u32, param: f32);
let glTexParameterfv:         *fn(target: u32, pname: u32, params: *f32);
let glTexParameteri:          *fn(target: u32, pname: u32, param: i32);
let glTexParameteriv:         *fn(target: u32, pname: u32, params: *i32);
let glTexImage1D:             *fn(target: u32, level: i32, internalformat: i32, width: i32, border: i32, format: u32, type: u32, pixels: *void);
let glTexImage2D:             *fn(target: u32, level: i32, internalformat: i32, width: i32, height: i32, border: i32, format: u32, type: u32, pixels: *void);
let glDrawBuffer:             *fn(buf: u32);
let glClear:                  *fn(mask: u32);
let glClearColor:             *fn(red: f32, green: f32, blue: f32, alpha: f32);
let glClearStencil:           *fn(s: i32);
let glClearDepth:             *fn(depth: f64);
let glStencilMask:            *fn(mask: u32);
let glColorMask:              *fn(red: u8, green: u8, blue: u8, alpha: u8);
let glDepthMask:              *fn(flag: u8);
let glDisable:                *fn(cap: u32);
let glEnable:                 *fn(cap: u32);
let glFinish:                 *fn();
let glFlush:                  *fn();
let glBlendFunc:              *fn(sfactor: u32, dfactor: u32);
let glLogicOp:                *fn(opcode: u32);
let glStencilFunc:            *fn(func: u32, ref: i32, mask: u32);
let glStencilOp:              *fn(fail: u32, zfail: u32, zpass: u32);
let glDepthFunc:              *fn(func: u32);
let glPixelStoref:            *fn(pname: u32, param: f32);
let glPixelStorei:            *fn(pname: u32, param: i32);
let glReadBuffer:             *fn(src: u32);
let glReadPixels:             *fn(x: i32, y: i32, width: i32, height: i32, format: u32, type: u32, pixels: *void);
let glGetBooleanv:            *fn(pname: u32, data: *u8);
let glGetDoublev:             *fn(pname: u32, data: *f64);
let glGetError:               *fn() -> u32;
let glGetFloatv:              *fn(pname: u32, data: *f32);
let glGetIntegerv:            *fn(pname: u32, data: *i32);
let glGetString:              *fn(name: u32) -> *u8;
let glGetTexImage:            *fn(target: u32,  level: i32, format: u32, type: u32, pixels: *void);
let glGetTexParameterfv:      *fn(target: u32, pname: u32, params: *f32);
let glGetTexParameteriv:      *fn(target: u32, pname: u32, params: *i32);
let glGetTexLevelParameterfv: *fn(target: u32, level: i32, pname: u32, params: *f32);
let glGetTexLevelParameteriv: *fn(target: u32, level: i32, pname: u32, params: *i32);
let glIsEnabled:              *fn(cap: u32) -> u8;
let glDepthRange:             *fn(near: f64, far: f64);
let glViewport:               *fn(x: i32, y: i32, width: i32, height: i32);

// 1.1
let glDrawArrays:        *fn(mode: u32, first: i32, count: i32);
let glDrawElements:      *fn(mode: u32, count: i32, type: u32, indices: *void);
let glPolygonOffset:     *fn(factor: f32, units: f32);
let glCopyTexImage1D:    *fn(target: u32, level: i32, internalformat: u32, x: i32, y: i32, width: i32, border: i32);
let glCopyTexImage2D:    *fn(target: u32, level: i32, internalformat: u32, x: i32, y: i32, width: i32, height: i32, border: i32);
let glCopyTexSubImage1D: *fn(target: u32, level: i32, xoffset: i32, x: i32, y: i32, width: i32);
let glCopyTexSubImage2D: *fn(target: u32, level: i32, xoffset: i32, yoffset: i32, x: i32, y: i32, width: i32, height: i32);
let glTexSubImage1D:     *fn(target: u32, level: i32, xoffset: i32, width: i32, format: u32, type: u32, pixels: *void);
let glTexSubImage2D:     *fn(target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, type: u32, pixels: *void);
let glBindTexture:       *fn(target: u32, texture: u32);
let glDeleteTextures:    *fn(n: i32, textures: *u32);
let glGenTextures:       *fn(n: i32, textures: *u32);
let glIsTexture:         *fn(texture: u32) -> u8;

// 1.2
let glDrawRangeElements: *fn(mode: u32, start: u32, end: u32, count: i32, type: u32, indices: *void);
let glTexImage3D:        *fn(target: u32, level: i32, internalformat: i32, width: i32, height: i32, depth: i32, border: i32, format: u32, type: u32, pixels: *void);
let glTexSubImage3D:     *fn(target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, type: u32, pixels: *void);
let glCopyTexSubImage3D: *fn(target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, x: i32, y: i32, width: i32, height: i32);

// 1.3
let glActiveTexture:           *fn(texture: u32);
let glSampleCoverage:          *fn(value: f32, invert: u8);
let glCompressedTexImage3D:    *fn(target: u32, level: i32, internalformat: u32, width: i32, height: i32, depth: i32, border: i32, imageSize: i32, data: *void);
let glCompressedTexImage2D:    *fn(target: u32, level: i32, internalformat: u32, width: i32, height: i32, border: i32, imageSize: i32, data: *void);
let glCompressedTexImage1D:    *fn(target: u32, level: i32, internalformat: u32, width: i32, border: i32, imageSize: i32, data: *void);
let glCompressedTexSubImage3D: *fn(target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, imageSize: i32, data: *void);
let glCompressedTexSubImage2D: *fn(target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, imageSize: i32, data: *void);
let glCompressedTexSubImage1D: *fn(target: u32, level: i32, xoffset: i32, width: i32, format: u32, imageSize: i32, data: *void);
let glGetCompressedTexImage:   *fn(target: u32, level: i32, img: *void);

// 1.4
let glBlendFuncSeparate: *fn(sfactorRGB: u32, dfactorRGB: u32, sfactorAlpha: u32, dfactorAlpha: u32);
let glMultiDrawArrays:   *fn(mode: u32, first: *i32, count: *i32, drawcount: i32);
let glMultiDrawElements: *fn(mode: u32, count: *i32, type: u32, indices: **void, drawcount: i32);
let glPointParameterf:   *fn(pname: u32, param: f32);
let glPointParameterfv:  *fn(pname: u32, params: *f32);
let glPointParameteri:   *fn(pname: u32, param: i32);
let glPointParameteriv:  *fn(pname: u32, params: *i32);
let glBlendColor:        *fn(red: f32, green: f32, blue: f32, alpha: f32);
let glBlendEquation:     *fn(mode: u32);

// 1.5
let glGenQueries:           *fn(n: i32, ids: *u32);
let glDeleteQueries:        *fn(n: i32, ids: *u32);
let glIsQuery:              *fn(id: u32) -> u8;
let glBeginQuery:           *fn(target: u32, id: u32);
let glEndQuery:             *fn(target: u32);
let glGetQueryiv:           *fn(target: u32, pname: u32, params: *i32);
let glGetQueryObjectiv:     *fn(id: u32, pname: u32, params: *i32);
let glGetQueryObjectuiv:    *fn(id: u32, pname: u32, params: *u32);
let glBindBuffer:           *fn(target: u32, buffer: u32);
let glDeleteBuffers:        *fn(n: i32, buffers: *u32);
let glGenBuffers:           *fn(n: i32, buffers: *u32);
let glIsBuffer:             *fn(buffer: u32) -> u8;
let glBufferData:           *fn(target: u32, size: i64, data: *void, usage: u32);
let glBufferSubData:        *fn(target: u32, offset: i64, size: i64, data: *void);
let glGetBufferSubData:     *fn(target: u32, offset: i64, size: i64, data: *void);
let glMapBuffer:            *fn(target: u32, access: u32) -> *void;
let glUnmapBuffer:          *fn(target: u32) -> u8;
let glGetBufferParameteriv: *fn(target: u32, pname: u32, params: *i32);
let glGetBufferPointerv:    *fn(target: u32, pname: u32, params: **void);

// 2.0
let glBlendEquationSeparate:    *fn(modeRGB: u32, modeAlpha: u32);
let glDrawBuffers:              *fn(n: i32, bufs: *u32);
let glStencilOpSeparate:        *fn(face: u32, sfail: u32, dpfail: u32, dppass: u32);
let glStencilFuncSeparate:      *fn(face: u32, func: u32, ref: i32, mask: u32);
let glStencilMaskSeparate:      *fn(face: u32, mask: u32);
let glAttachShader:             *fn(program: u32, shader: u32);
let glBindAttribLocation:       *fn(program: u32, index: u32, name: *u8);
let glCompileShader:            *fn(shader: u32);
let glCreateProgram:            *fn() -> u32;
let glCreateShader:             *fn(type: u32) -> u32;
let glDeleteProgram:            *fn(program: u32);
let glDeleteShader:             *fn(shader: u32);
let glDetachShader:             *fn(program: u32, shader: u32);
let glDisableVertexAttribArray: *fn(index: u32);
let glEnableVertexAttribArray:  *fn(index: u32);
let glGetActiveAttrib:          *fn(program: u32, index: u32, bufSize: i32, length: *i32, size: *i32, type: *u32, name: *u8);
let glGetActiveUniform:         *fn(program: u32, index: u32, bufSize: i32, length: *i32, size: *i32, type: *u32, name: *u8);
let glGetAttachedShaders:       *fn(program: u32, maxCount: i32, count: *i32, shaders: *u32);
let glGetAttribLocation:        *fn(program: u32, name: *u8) -> i32;
let glGetProgramiv:             *fn(program: u32, pname: u32, params: *i32);
let glGetProgramInfoLog:        *fn(program: u32, bufSize: i32, length: *i32, infoLog: *u8);
let glGetShaderiv:              *fn(shader: u32, pname: u32, params: *i32);
let glGetShaderInfoLog:         *fn(shader: u32, bufSize: i32, length: *i32, infoLog: *u8);
let glGetShaderSource:          *fn(shader: u32, bufSize: i32, length: *i32, source: *u8);
let glGetUniformLocation:       *fn(program: u32, name: *u8) -> i32;
let glGetUniformfv:             *fn(program: u32, location: i32, params: *f32);
let glGetUniformiv:             *fn(program: u32, location: i32, params: *i32);
let glGetVertexAttribdv:        *fn(index: u32, pname: u32, params: *f64);
let glGetVertexAttribfv:        *fn(index: u32, pname: u32, params: *f32);
let glGetVertexAttribiv:        *fn(index: u32, pname: u32, params: *i32);
let glGetVertexAttribPointerv:  *fn(index: u32, pname: u32, pointer: **void);
let glIsProgram:                *fn(program: u32) -> u8;
let glIsShader:                 *fn(shader: u32) -> u8;
let glLinkProgram:              *fn(program: u32);
let glShaderSource:             *fn(shader: u32, count: i32, string: **u8, length: *i32);
let glUseProgram:               *fn(program: u32);
let glUniform1f:                *fn(location: i32, v0: f32);
let glUniform2f:                *fn(location: i32, v0: f32, v1: f32);
let glUniform3f:                *fn(location: i32, v0: f32, v1: f32, v2: f32);
let glUniform4f:                *fn(location: i32, v0: f32, v1: f32, v2: f32, v3: f32);
let glUniform1i:                *fn(location: i32, v0: i32);
let glUniform2i:                *fn(location: i32, v0: i32, v1: i32);
let glUniform3i:                *fn(location: i32, v0: i32, v1: i32, v2: i32);
let glUniform4i:                *fn(location: i32, v0: i32, v1: i32, v2: i32, v3: i32);
let glUniform1fv:               *fn(location: i32, count: i32, value: *f32);
let glUniform2fv:               *fn(location: i32, count: i32, value: *f32);
let glUniform3fv:               *fn(location: i32, count: i32, value: *f32);
let glUniform4fv:               *fn(location: i32, count: i32, value: *f32);
let glUniform1iv:               *fn(location: i32, count: i32, value: *i32);
let glUniform2iv:               *fn(location: i32, count: i32, value: *i32);
let glUniform3iv:               *fn(location: i32, count: i32, value: *i32);
let glUniform4iv:               *fn(location: i32, count: i32, value: *i32);
let glUniformMatrix2fv:         *fn(location: i32, count: i32, transpose: u8, value: *f32);
let glUniformMatrix3fv:         *fn(location: i32, count: i32, transpose: u8, value: *f32);
let glUniformMatrix4fv:         *fn(location: i32, count: i32, transpose: u8, value: *f32);
let glValidateProgram:          *fn(program: u32);
let glVertexAttrib1d:           *fn(index: u32, x: f64);
let glVertexAttrib1dv:          *fn(index: u32, v: *f64);
let glVertexAttrib1f:           *fn(index: u32, x: f32);
let glVertexAttrib1fv:          *fn(index: u32, v: *f32);
let glVertexAttrib1s:           *fn(index: u32, x: i16);
let glVertexAttrib1sv:          *fn(index: u32, v: *i16);
let glVertexAttrib2d:           *fn(index: u32, x: f64, y: f64);
let glVertexAttrib2dv:          *fn(index: u32, v: *f64);
let glVertexAttrib2f:           *fn(index: u32, x: f32, y: f32);
let glVertexAttrib2fv:          *fn(index: u32, v: *f32);
let glVertexAttrib2s:           *fn(index: u32, x: i16, y: i16);
let glVertexAttrib2sv:          *fn(index: u32, v: *i16);
let glVertexAttrib3d:           *fn(index: u32, x: f64, y: f64, z: f64);
let glVertexAttrib3dv:          *fn(index: u32, v: *f64);
let glVertexAttrib3f:           *fn(index: u32, x: f32, y: f32, z: f32);
let glVertexAttrib3fv:          *fn(index: u32, v: *f32);
let glVertexAttrib3s:           *fn(index: u32, x: i16, y: i16, z: i16);
let glVertexAttrib3sv:          *fn(index: u32, v: *i16);
let glVertexAttrib4Nbv:         *fn(index: u32, v: *i8);
let glVertexAttrib4Niv:         *fn(index: u32, v: *i32);
let glVertexAttrib4Nsv:         *fn(index: u32, v: *i16);
let glVertexAttrib4Nub:         *fn(index: u32, x: u8, y: u8, z: u8, w: u8);
let glVertexAttrib4Nubv:        *fn(index: u32, v: *u8);
let glVertexAttrib4Nuiv:        *fn(index: u32, v: *u32);
let glVertexAttrib4Nusv:        *fn(index: u32, v: *u16);
let glVertexAttrib4bv:          *fn(index: u32, v: *i8);
let glVertexAttrib4d:           *fn(index: u32, x: f64, y: f64, z: f64, w: f64);
let glVertexAttrib4dv:          *fn(index: u32, v: *f64);
let glVertexAttrib4f:           *fn(index: u32, x: f32, y: f32, z: f32, w: f32);
let glVertexAttrib4fv:          *fn(index: u32, v: *f32);
let glVertexAttrib4iv:          *fn(index: u32, v: *i32);
let glVertexAttrib4s:           *fn(index: u32, x: i16, y: i16, z: i16, w: i16);
let glVertexAttrib4sv:          *fn(index: u32, v: *i16);
let glVertexAttrib4ubv:         *fn(index: u32, v: *u8);
let glVertexAttrib4uiv:         *fn(index: u32, v: *u32);
let glVertexAttrib4usv:         *fn(index: u32, v: *u16);
let glVertexAttribPointer:      *fn(index: u32, size: i32, type: u32, normalized: u8, stride: i32, pointer: *void);

// 2.1
let glUniformMatrix2x3fv: *fn(location: i32, count: i32, transpose: u8, value: *f32);
let glUniformMatrix3x2fv: *fn(location: i32, count: i32, transpose: u8, value: *f32);
let glUniformMatrix2x4fv: *fn(location: i32, count: i32, transpose: u8, value: *f32);
let glUniformMatrix4x2fv: *fn(location: i32, count: i32, transpose: u8, value: *f32);
let glUniformMatrix3x4fv: *fn(location: i32, count: i32, transpose: u8, value: *f32);
let glUniformMatrix4x3fv: *fn(location: i32, count: i32, transpose: u8, value: *f32);

// 3.0
let glColorMaski:                          *fn(index: u32, r: u8, g: u8, b: u8, a: u8);
let glGetBooleani_v:                       *fn(target: u32, index: u32, data: *u8);
let glGetIntegeri_v:                       *fn(target: u32, index: u32, data: *i32);
let glEnablei:                             *fn(target: u32, index: u32);
let glDisablei:                            *fn(target: u32, index: u32);
let glIsEnabledi:                          *fn(target: u32, index: u32) -> u8;
let glBeginTransformFeedback:              *fn(primitiveMode: u32);
let glEndTransformFeedback:                *fn();
let glBindBufferRange:                     *fn(target: u32, index: u32, buffer: u32, offset: i64, size: i64);
let glBindBufferBase:                      *fn(target: u32, index: u32, buffer: u32);
let glTransformFeedbackVaryings:           *fn(program: u32, count: i32, varyings: *u8, bufferMode: u32);
let glGetTransformFeedbackVarying:         *fn(program: u32, index: u32, bufSize: i32, length: *i32, size: *i32, type: *u32, name: *u8);
let glClampColor:                          *fn(target: u32, clamp: u32);
let glBeginConditionalRender:              *fn(id: u32, mode: u32);
let glEndConditionalRender:                *fn();
let glVertexAttribIPointer:                *fn(index: u32, size: i32, type: u32, stride: i32, pointer: *void);
let glGetVertexAttribIiv:                  *fn(index: u32, pname: u32, params: *i32);
let glGetVertexAttribIuiv:                 *fn(index: u32, pname: u32, params: *u32);
let glVertexAttribI1i:                     *fn(index: u32, x: i32);
let glVertexAttribI2i:                     *fn(index: u32, x: i32, y: i32);
let glVertexAttribI3i:                     *fn(index: u32, x: i32, y: i32, z: i32);
let glVertexAttribI4i:                     *fn(index: u32, x: i32, y: i32, z: i32, w: i32);
let glVertexAttribI1ui:                    *fn(index: u32, x: u32);
let glVertexAttribI2ui:                    *fn(index: u32, x: u32, y: u32);
let glVertexAttribI3ui:                    *fn(index: u32, x: u32, y: u32, z: u32);
let glVertexAttribI4ui:                    *fn(index: u32, x: u32, y: u32, z: u32, w: u32);
let glVertexAttribI1iv:                    *fn(index: u32, v: *i32);
let glVertexAttribI2iv:                    *fn(index: u32, v: *i32);
let glVertexAttribI3iv:                    *fn(index: u32, v: *i32);
let glVertexAttribI4iv:                    *fn(index: u32, v: *i32);
let glVertexAttribI1uiv:                   *fn(index: u32, v: *u32);
let glVertexAttribI2uiv:                   *fn(index: u32, v: *u32);
let glVertexAttribI3uiv:                   *fn(index: u32, v: *u32);
let glVertexAttribI4uiv:                   *fn(index: u32, v: *u32);
let glVertexAttribI4bv:                    *fn(index: u32, v: *i8);
let glVertexAttribI4sv:                    *fn(index: u32, v: *i16);
let glVertexAttribI4ubv:                   *fn(index: u32, v: *u8);
let glVertexAttribI4usv:                   *fn(index: u32, v: *u16);
let glGetUniformuiv:                       *fn(program: u32, location: i32, params: *u32);
let glBindFragDataLocation:                *fn(program: u32, color: u32, name: *u8);
let glGetFragDataLocation:                 *fn(program: u32, name: *u8) -> i32;
let glUniform1ui:                          *fn(location: i32, v0: u32);
let glUniform2ui:                          *fn(location: i32, v0: u32, v1: u32);
let glUniform3ui:                          *fn(location: i32, v0: u32, v1: u32, v2: u32);
let glUniform4ui:                          *fn(location: i32, v0: u32, v1: u32, v2: u32, v3: u32);
let glUniform1uiv:                         *fn(location: i32, count: i32, value: *u32);
let glUniform2uiv:                         *fn(location: i32, count: i32, value: *u32);
let glUniform3uiv:                         *fn(location: i32, count: i32, value: *u32);
let glUniform4uiv:                         *fn(location: i32, count: i32, value: *u32);
let glTexParameterIiv:                     *fn(target: u32, pname: u32, params: *i32);
let glTexParameterIuiv:                    *fn(target: u32, pname: u32, params: *u32);
let glGetTexParameterIiv:                  *fn(target: u32, pname: u32, params: *i32);
let glGetTexParameterIuiv:                 *fn(target: u32, pname: u32, params: *u32);
let glClearBufferiv:                       *fn(buffer: u32, drawbuffer: i32, value: *i32);
let glClearBufferuiv:                      *fn(buffer: u32, drawbuffer: i32, value: *u32);
let glClearBufferfv:                       *fn(buffer: u32, drawbuffer: i32, value: *f32);
let glClearBufferfi:                       *fn(buffer: u32, drawbuffer: i32, depth: f32, stencil: i32) -> *void;
let glGetStringi:                          *fn(name: u32, index: u32) -> u8;
let glIsRenderbuffer:                      *fn(renderbuffer: u32) -> u8;
let glBindRenderbuffer:                    *fn(target: u32, renderbuffer: u32);
let glDeleteRenderbuffers:                 *fn(n: i32, renderbuffers: *u32);
let glGenRenderbuffers:                    *fn(n: i32, renderbuffers: *u32);
let glRenderbufferStorage:                 *fn(target: u32, internalformat: u32, width: i32, height: i32);
let glGetRenderbufferParameteriv:          *fn(target: u32, pname: u32, params: *i32);
let glIsFramebuffer:                       *fn(framebuffer: u32) -> u8;
let glBindFramebuffer:                     *fn(target: u32, framebuffer: u32);
let glDeleteFramebuffers:                  *fn(n: i32, framebuffers: *u32);
let glGenFramebuffers:                     *fn(n: i32, framebuffers: *u32);
let glCheckFramebufferStatus:              *fn(target: u32) -> u32;
let glFramebufferTexture1D:                *fn(target: u32, attachment: u32, textarget: u32, texture: u32, level: i32);
let glFramebufferTexture2D:                *fn(target: u32, attachment: u32, textarget: u32, texture: u32, level: i32);
let glFramebufferTexture3D:                *fn(target: u32, attachment: u32, textarget: u32, texture: u32, level: i32, zoffset: i32);
let glFramebufferRenderbuffer:             *fn(target: u32, attachment: u32, renderbuffertarget: u32, renderbuffer: u32);
let glGetFramebufferAttachmentParameteriv: *fn(target: u32, attachment: u32, pname: u32, params: *i32);
let glGenerateMipmap:                      *fn(target: u32);
let glBlitFramebuffer:                     *fn(srcX0: i32, srcY0: i32, srcX1: i32, srcY1: i32, dstX0: i32, dstY0: i32, dstX1: i32, dstY1: i32, mask: u32, filter: u32);
let glRenderbufferStorageMultisample:      *fn(target: u32, samples: i32, internalformat: u32, width: i32, height: i32);
let glFramebufferTextureLayer:             *fn(target: u32, attachment: u32, texture: u32, level: i32, layer: i32);
let glMapBufferRange:                      *fn(target: u32, offset: i64, length: i64, access: u32) -> *void;
let glFlushMappedBufferRange:              *fn(target: u32, offset: i64, length: i64);
let glBindVertexArray:                     *fn(array: u32);
let glDeleteVertexArrays:                  *fn(n: i32, arrays: *u32);
let glGenVertexArrays:                     *fn(n: i32, arrays: *u32);
let glIsVertexArray:                       *fn(array: u32) -> u8;

// 3.1
let glDrawArraysInstanced:       *fn(mode: u32, first: i32, count: i32, instancecount: i32);
let glDrawElementsInstanced:     *fn(mode: u32, count: i32, type: u32, indices: *void, instancecount: i32);
let glTexBuffer:                 *fn(target: u32, internalformat: u32, buffer: u32);
let glPrimitiveRestartIndex:     *fn(index: u32);
let glCopyBufferSubData:         *fn(readTarget: u32, writeTarget: u32, readOffset: i64, writeOffset: i64, size: i64);
let glGetUniformIndices:         *fn(program: u32, uniformCount: i32, uniformNames: *u8, uniformIndices: *u32);
let glGetActiveUniformsiv:       *fn(program: u32, uniformCount: i32, uniformIndices: *u32, pname: u32, params: *i32);
let glGetActiveUniformName:      *fn(program: u32, uniformIndex: u32, bufSize: i32, length: *i32, uniformName: *u8);
let glGetUniformBlockIndex:      *fn(program: u32, uniformBlockName: *u8) -> u32;
let glGetActiveUniformBlockiv:   *fn(program: u32, uniformBlockIndex: u32, pname: u32, params: *i32);
let glGetActiveUniformBlockName: *fn(program: u32, uniformBlockIndex: u32, bufSize: i32, length: *i32, uniformBlockName: *u8);
let glUniformBlockBinding:       *fn(program: u32, uniformBlockIndex: u32, uniformBlockBinding: u32);

// 3.2
let glDrawElementsBaseVertex:          *fn(mode: u32, count: i32, type: u32, indices: *void, basevertex: i32);
let glDrawRangeElementsBaseVertex:     *fn(mode: u32, start: u32, end: u32, count: i32, type: u32, indices: *void, basevertex: i32);
let glDrawElementsInstancedBaseVertex: *fn(mode: u32, count: i32, type: u32, indices: *void, instancecount: i32, basevertex: i32);
let glMultiDrawElementsBaseVertex:     *fn(mode: u32, count: *i32, type: u32, indices: **void, drawcount: i32, basevertex: *i32);
let glProvokingVertex:                 *fn(mode: u32);
let glFenceSync:                       *fn(condition: u32, flags: u32) -> *void;
let glIsSync:                          *fn(sync: *void) -> u8;
let glDeleteSync:                      *fn(sync: *void);
let glClientWaitSync:                  *fn(sync: *void, flags: u32, timeout: u64) -> u32;
let glWaitSync:                        *fn(sync: *void, flags: u32, timeout: u64);
let glGetInteger64v:                   *fn(pname: u32, data: *i64);
let glGetSynciv:                       *fn(sync: *void, pname: u32, bufSize: i32, length: *i32, values: *i32);
let glGetInteger64i_v:                 *fn(target: u32, index: u32, data: *i64);
let glGetBufferParameteri64v:          *fn(target: u32, pname: u32, params: *i64);
let glFramebufferTexture:              *fn(target: u32, attachment: u32, texture: u32, level: i32);
let glTexImage2DMultisample:           *fn(target: u32, samples: i32, internalformat: u32, width: i32, height: i32, fixedsamplelocations: u8);
let glTexImage3DMultisample:           *fn(target: u32, samples: i32, internalformat: u32, width: i32, height: i32, depth: i32, fixedsamplelocations: u8);
let glGetMultisamplefv:                *fn(pname: u32, index: u32, val: *f32);
let glSampleMaski:                     *fn(maskNumber: u32, mask: u32);

// 3.3
let glBindFragDataLocationIndexed: *fn(program: u32, colorNumber: u32, index: u32, name: *u8);
let glGetFragDataIndex:            *fn(program: u32, name: *u8) -> i32;
let glGenSamplers:                 *fn(count: i32, samplers: *u32);
let glDeleteSamplers:              *fn(count: i32, samplers: *u32);
let glIsSampler:                   *fn(sampler: u32) -> u8;
let glBindSampler:                 *fn(unit: u32, sampler: u32);
let glSamplerParameteri:           *fn(sampler: u32, pname: u32, param: i32);
let glSamplerParameteriv:          *fn(sampler: u32, pname: u32, param: *i32);
let glSamplerParameterf:           *fn(sampler: u32, pname: u32, param: f32);
let glSamplerParameterfv:          *fn(sampler: u32, pname: u32, param: *f32);
let glSamplerParameterIiv:         *fn(sampler: u32, pname: u32, param: *i32);
let glSamplerParameterIuiv:        *fn(sampler: u32, pname: u32, param: *u32);
let glGetSamplerParameteriv:       *fn(sampler: u32, pname: u32, params: *i32);
let glGetSamplerParameterIiv:      *fn(sampler: u32, pname: u32, params: *i32);
let glGetSamplerParameterfv:       *fn(sampler: u32, pname: u32, params: *f32);
let glGetSamplerParameterIuiv:     *fn(sampler: u32, pname: u32, params: *u32);
let glQueryCounter:                *fn(id: u32, target: u32);
let glGetQueryObjecti64v:          *fn(id: u32, pname: u32, params: *i64);
let glGetQueryObjectui64v:         *fn(id: u32, pname: u32, params: *u64);
let glVertexAttribDivisor:         *fn(index: u32, divisor: u32);
let glVertexAttribP1ui:            *fn(index: u32, type: u32, normalized: u8, value: u32);
let glVertexAttribP1uiv:           *fn(index: u32, type: u32, normalized: u8, value: *u32);
let glVertexAttribP2ui:            *fn(index: u32, type: u32, normalized: u8, value: u32);
let glVertexAttribP2uiv:           *fn(index: u32, type: u32, normalized: u8, value: *u32);
let glVertexAttribP3ui:            *fn(index: u32, type: u32, normalized: u8, value: u32);
let glVertexAttribP3uiv:           *fn(index: u32, type: u32, normalized: u8, value: *u32);
let glVertexAttribP4ui:            *fn(index: u32, type: u32, normalized: u8, value: u32);
let glVertexAttribP4uiv:           *fn(index: u32, type: u32, normalized: u8, value: *u32);
let glVertexP2ui:                  *fn(type: u32, value: u32);
let glVertexP2uiv:                 *fn(type: u32, value: *u32);
let glVertexP3ui:                  *fn(type: u32, value: u32);
let glVertexP3uiv:                 *fn(type: u32, value: *u32);
let glVertexP4ui:                  *fn(type: u32, value: u32);
let glVertexP4uiv:                 *fn(type: u32, value: *u32);
let glTexCoordP1ui:                *fn(type: u32, coords: u32);
let glTexCoordP1uiv:               *fn(type: u32, coords: *u32);
let glTexCoordP2ui:                *fn(type: u32, coords: u32);
let glTexCoordP2uiv:               *fn(type: u32, coords: *u32);
let glTexCoordP3ui:                *fn(type: u32, coords: u32);
let glTexCoordP3uiv:               *fn(type: u32, coords: *u32);
let glTexCoordP4ui:                *fn(type: u32, coords: u32);
let glTexCoordP4uiv:               *fn(type: u32, coords: *u32);
let glMultiTexCoordP1ui:           *fn(texture: u32, type: u32, coords: u32);
let glMultiTexCoordP1uiv:          *fn(texture: u32, type: u32, coords: *u32);
let glMultiTexCoordP2ui:           *fn(texture: u32, type: u32, coords: u32);
let glMultiTexCoordP2uiv:          *fn(texture: u32, type: u32, coords: *u32);
let glMultiTexCoordP3ui:           *fn(texture: u32, type: u32, coords: u32);
let glMultiTexCoordP3uiv:          *fn(texture: u32, type: u32, coords: *u32);
let glMultiTexCoordP4ui:           *fn(texture: u32, type: u32, coords: u32);
let glMultiTexCoordP4uiv:          *fn(texture: u32, type: u32, coords: *u32);
let glNormalP3ui:                  *fn(type: u32, coords: u32);
let glNormalP3uiv:                 *fn(type: u32, coords: *u32);
let glColorP3ui:                   *fn(type: u32, color: u32);
let glColorP3uiv:                  *fn(type: u32, color: *u32);
let glColorP4ui:                   *fn(type: u32, color: u32);
let glColorP4uiv:                  *fn(type: u32, color: *u32);
let glSecondaryColorP3ui:          *fn(type: u32, color: u32);
let glSecondaryColorP3uiv:         *fn(type: u32, color: *u32); 


let GL_FALSE                          = 0;
let GL_TRUE                           = 1;
let GL_DEPTH_BUFFER_BIT               = 0x00000100;
let GL_STENCIL_BUFFER_BIT             = 0x00000400;
let GL_COLOR_BUFFER_BIT               = 0x00004000;
let GL_POINTS                         = 0x0000;
let GL_LINES                          = 0x0001;
let GL_LINE_LOOP                      = 0x0002;
let GL_LINE_STRIP                     = 0x0003;
let GL_TRIANGLES                      = 0x0004;
let GL_TRIANGLE_STRIP                 = 0x0005;
let GL_TRIANGLE_FAN                   = 0x0006;
let GL_QUADS                          = 0x0007;
let GL_NEVER                          = 0x0200;
let GL_LESS                           = 0x0201;
let GL_EQUAL                          = 0x0202;
let GL_LEQUAL                         = 0x0203;
let GL_GREATER                        = 0x0204;
let GL_NOTEQUAL                       = 0x0205;
let GL_GEQUAL                         = 0x0206;
let GL_ALWAYS                         = 0x0207;
let GL_ZERO                           = 0;
let GL_ONE                            = 1;
let GL_SRC_COLOR                      = 0x0300;
let GL_ONE_MINUS_SRC_COLOR            = 0x0301;
let GL_SRC_ALPHA                      = 0x0302;
let GL_ONE_MINUS_SRC_ALPHA            = 0x0303;
let GL_DST_ALPHA                      = 0x0304;
let GL_ONE_MINUS_DST_ALPHA            = 0x0305;
let GL_DST_COLOR                      = 0x0306;
let GL_ONE_MINUS_DST_COLOR            = 0x0307;
let GL_SRC_ALPHA_SATURATE             = 0x0308;
let GL_NONE                           = 0;
let GL_FRONT_LEFT                     = 0x0400;
let GL_FRONT_RIGHT                    = 0x0401;
let GL_BACK_LEFT                      = 0x0402;
let GL_BACK_RIGHT                     = 0x0403;
let GL_FRONT                          = 0x0404;
let GL_BACK                           = 0x0405;
let GL_LEFT                           = 0x0406;
let GL_RIGHT                          = 0x0407;
let GL_FRONT_AND_BACK                 = 0x0408;
let GL_NO_ERROR                       = 0;
let GL_INVALID_ENUM                   = 0x0500;
let GL_INVALID_VALUE                  = 0x0501;
let GL_INVALID_OPERATION              = 0x0502;
let GL_OUT_OF_MEMORY                  = 0x0505;
let GL_CW                             = 0x0900;
let GL_CCW                            = 0x0901;
let GL_POINT_SIZE                     = 0x0B11;
let GL_POINT_SIZE_RANGE               = 0x0B12;
let GL_POINT_SIZE_GRANULARITY         = 0x0B13;
let GL_LINE_SMOOTH                    = 0x0B20;
let GL_LINE_WIDTH                     = 0x0B21;
let GL_LINE_WIDTH_RANGE               = 0x0B22;
let GL_LINE_WIDTH_GRANULARITY         = 0x0B23;
let GL_POLYGON_MODE                   = 0x0B40;
let GL_POLYGON_SMOOTH                 = 0x0B41;
let GL_CULL_FACE                      = 0x0B44;
let GL_CULL_FACE_MODE                 = 0x0B45;
let GL_FRONT_FACE                     = 0x0B46;
let GL_DEPTH_RANGE                    = 0x0B70;
let GL_DEPTH_TEST                     = 0x0B71;
let GL_DEPTH_WRITEMASK                = 0x0B72;
let GL_DEPTH_CLEAR_VALUE              = 0x0B73;
let GL_DEPTH_FUNC                     = 0x0B74;
let GL_STENCIL_TEST                   = 0x0B90;
let GL_STENCIL_CLEAR_VALUE            = 0x0B91;
let GL_STENCIL_FUNC                   = 0x0B92;
let GL_STENCIL_VALUE_MASK             = 0x0B93;
let GL_STENCIL_FAIL                   = 0x0B94;
let GL_STENCIL_PASS_DEPTH_FAIL        = 0x0B95;
let GL_STENCIL_PASS_DEPTH_PASS        = 0x0B96;
let GL_STENCIL_REF                    = 0x0B97;
let GL_STENCIL_WRITEMASK              = 0x0B98;
let GL_VIEWPORT                       = 0x0BA2;
let GL_DITHER                         = 0x0BD0;
let GL_BLEND_DST                      = 0x0BE0;
let GL_BLEND_SRC                      = 0x0BE1;
let GL_BLEND                          = 0x0BE2;
let GL_LOGIC_OP_MODE                  = 0x0BF0;
let GL_COLOR_LOGIC_OP                 = 0x0BF2;
let GL_DRAW_BUFFER                    = 0x0C01;
let GL_READ_BUFFER                    = 0x0C02;
let GL_SCISSOR_BOX                    = 0x0C10;
let GL_SCISSOR_TEST                   = 0x0C11;
let GL_COLOR_CLEAR_VALUE              = 0x0C22;
let GL_COLOR_WRITEMASK                = 0x0C23;
let GL_DOUBLEBUFFER                   = 0x0C32;
let GL_STEREO                         = 0x0C33;
let GL_LINE_SMOOTH_HINT               = 0x0C52;
let GL_POLYGON_SMOOTH_HINT            = 0x0C53;
let GL_UNPACK_SWAP_BYTES              = 0x0CF0;
let GL_UNPACK_LSB_FIRST               = 0x0CF1;
let GL_UNPACK_ROW_LENGTH              = 0x0CF2;
let GL_UNPACK_SKIP_ROWS               = 0x0CF3;
let GL_UNPACK_SKIP_PIXELS             = 0x0CF4;
let GL_UNPACK_ALIGNMENT               = 0x0CF5;
let GL_PACK_SWAP_BYTES                = 0x0D00;
let GL_PACK_LSB_FIRST                 = 0x0D01;
let GL_PACK_ROW_LENGTH                = 0x0D02;
let GL_PACK_SKIP_ROWS                 = 0x0D03;
let GL_PACK_SKIP_PIXELS               = 0x0D04;
let GL_PACK_ALIGNMENT                 = 0x0D05;
let GL_MAX_TEXTURE_SIZE               = 0x0D33;
let GL_MAX_VIEWPORT_DIMS              = 0x0D3A;
let GL_SUBPIXEL_BITS                  = 0x0D50;
let GL_TEXTURE_1D                     = 0x0DE0;
let GL_TEXTURE_2D                     = 0x0DE1;
let GL_POLYGON_OFFSET_UNITS           = 0x2A00;
let GL_POLYGON_OFFSET_POINT           = 0x2A01;
let GL_POLYGON_OFFSET_LINE            = 0x2A02;
let GL_POLYGON_OFFSET_FILL            = 0x8037;
let GL_POLYGON_OFFSET_FACTOR          = 0x8038;
let GL_TEXTURE_BINDING_1D             = 0x8068;
let GL_TEXTURE_BINDING_2D             = 0x8069;
let GL_TEXTURE_WIDTH                  = 0x1000;
let GL_TEXTURE_HEIGHT                 = 0x1001;
let GL_TEXTURE_INTERNAL_FORMAT        = 0x1003;
let GL_TEXTURE_BORDER_COLOR           = 0x1004;
let GL_TEXTURE_RED_SIZE               = 0x805C;
let GL_TEXTURE_GREEN_SIZE             = 0x805D;
let GL_TEXTURE_BLUE_SIZE              = 0x805E;
let GL_TEXTURE_ALPHA_SIZE             = 0x805F;
let GL_DONT_CARE                      = 0x1100;
let GL_FASTEST                        = 0x1101;
let GL_NICEST                         = 0x1102;
let GL_BYTE                           = 0x1400;
let GL_UNSIGNED_BYTE                  = 0x1401;
let GL_SHORT                          = 0x1402;
let GL_UNSIGNED_SHORT                 = 0x1403;
let GL_INT                            = 0x1404;
let GL_UNSIGNED_INT                   = 0x1405;
let GL_FLOAT                          = 0x1406;
let GL_DOUBLE                         = 0x140A;
let GL_STACK_OVERFLOW                 = 0x0503;
let GL_STACK_UNDERFLOW                = 0x0504;
let GL_CLEAR                          = 0x1500;
let GL_AND                            = 0x1501;
let GL_AND_REVERSE                    = 0x1502;
let GL_COPY                           = 0x1503;
let GL_AND_INVERTED                   = 0x1504;
let GL_NOOP                           = 0x1505;
let GL_XOR                            = 0x1506;
let GL_OR                             = 0x1507;
let GL_NOR                            = 0x1508;
let GL_EQUIV                          = 0x1509;
let GL_INVERT                         = 0x150A;
let GL_OR_REVERSE                     = 0x150B;
let GL_COPY_INVERTED                  = 0x150C;
let GL_OR_INVERTED                    = 0x150D;
let GL_NAND                           = 0x150E;
let GL_SET                            = 0x150F;
let GL_TEXTURE                        = 0x1702;
let GL_COLOR                          = 0x1800;
let GL_DEPTH                          = 0x1801;
let GL_STENCIL                        = 0x1802;
let GL_STENCIL_INDEX                  = 0x1901;
let GL_DEPTH_COMPONENT                = 0x1902;
let GL_RED                            = 0x1903;
let GL_GREEN                          = 0x1904;
let GL_BLUE                           = 0x1905;
let GL_ALPHA                          = 0x1906;
let GL_RGB                            = 0x1907;
let GL_RGBA                           = 0x1908;
let GL_POINT                          = 0x1B00;
let GL_LINE                           = 0x1B01;
let GL_FILL                           = 0x1B02;
let GL_KEEP                           = 0x1E00;
let GL_REPLACE                        = 0x1E01;
let GL_INCR                           = 0x1E02;
let GL_DECR                           = 0x1E03;
let GL_VENDOR                         = 0x1F00;
let GL_RENDERER                       = 0x1F01;
let GL_VERSION                        = 0x1F02;
let GL_EXTENSIONS                     = 0x1F03;
let GL_NEAREST                        = 0x2600;
let GL_LINEAR                         = 0x2601;
let GL_NEAREST_MIPMAP_NEAREST         = 0x2700;
let GL_LINEAR_MIPMAP_NEAREST          = 0x2701;
let GL_NEAREST_MIPMAP_LINEAR          = 0x2702;
let GL_LINEAR_MIPMAP_LINEAR           = 0x2703;
let GL_TEXTURE_MAG_FILTER             = 0x2800;
let GL_TEXTURE_MIN_FILTER             = 0x2801;
let GL_TEXTURE_WRAP_S                 = 0x2802;
let GL_TEXTURE_WRAP_T                 = 0x2803;
let GL_PROXY_TEXTURE_1D               = 0x8063;
let GL_PROXY_TEXTURE_2D               = 0x8064;
let GL_REPEAT                         = 0x2901;
let GL_R3_G3_B2                       = 0x2A10;
let GL_RGB4                           = 0x804F;
let GL_RGB5                           = 0x8050;
let GL_RGB8                           = 0x8051;
let GL_RGB10                          = 0x8052;
let GL_RGB12                          = 0x8053;
let GL_RGB16                          = 0x8054;
let GL_RGBA2                          = 0x8055;
let GL_RGBA4                          = 0x8056;
let GL_RGB5_A1                        = 0x8057;
let GL_RGBA8                          = 0x8058;
let GL_RGB10_A2                       = 0x8059;
let GL_RGBA12                         = 0x805A;
let GL_RGBA16                         = 0x805B;
let GL_VERTEX_ARRAY                   = 0x8074;
let GL_UNSIGNED_BYTE_3_3_2            = 0x8032;
let GL_UNSIGNED_SHORT_4_4_4_4         = 0x8033;
let GL_UNSIGNED_SHORT_5_5_5_1         = 0x8034;
let GL_UNSIGNED_INT_8_8_8_8           = 0x8035;
let GL_UNSIGNED_INT_10_10_10_2        = 0x8036;
let GL_TEXTURE_BINDING_3D             = 0x806A;
let GL_PACK_SKIP_IMAGES               = 0x806B;
let GL_PACK_IMAGE_HEIGHT              = 0x806C;
let GL_UNPACK_SKIP_IMAGES             = 0x806D;
let GL_UNPACK_IMAGE_HEIGHT            = 0x806E;
let GL_TEXTURE_3D                     = 0x806F;
let GL_PROXY_TEXTURE_3D               = 0x8070;
let GL_TEXTURE_DEPTH                  = 0x8071;
let GL_TEXTURE_WRAP_R                 = 0x8072;
let GL_MAX_3D_TEXTURE_SIZE            = 0x8073;
let GL_UNSIGNED_BYTE_2_3_3_REV        = 0x8362;
let GL_UNSIGNED_SHORT_5_6_5           = 0x8363;
let GL_UNSIGNED_SHORT_5_6_5_REV       = 0x8364;
let GL_UNSIGNED_SHORT_4_4_4_4_REV     = 0x8365;
let GL_UNSIGNED_SHORT_1_5_5_5_REV     = 0x8366;
let GL_UNSIGNED_INT_8_8_8_8_REV       = 0x8367;
let GL_UNSIGNED_INT_2_10_10_10_REV    = 0x8368;
let GL_BGR                            = 0x80E0;
let GL_BGRA                           = 0x80E1;
let GL_MAX_ELEMENTS_VERTICES          = 0x80E8;
let GL_MAX_ELEMENTS_INDICES           = 0x80E9;
let GL_CLAMP_TO_EDGE                  = 0x812F;
let GL_TEXTURE_MIN_LOD                = 0x813A;
let GL_TEXTURE_MAX_LOD                = 0x813B;
let GL_TEXTURE_BASE_LEVEL             = 0x813C;
let GL_TEXTURE_MAX_LEVEL              = 0x813D;
let GL_SMOOTH_POINT_SIZE_RANGE        = 0x0B12;
let GL_SMOOTH_POINT_SIZE_GRANULARITY  = 0x0B13;
let GL_SMOOTH_LINE_WIDTH_RANGE        = 0x0B22;
let GL_SMOOTH_LINE_WIDTH_GRANULARITY  = 0x0B23;
let GL_ALIASED_LINE_WIDTH_RANGE       = 0x846E;
let GL_TEXTURE0                       = 0x84C0;
let GL_TEXTURE1                       = 0x84C1;
let GL_TEXTURE2                       = 0x84C2;
let GL_TEXTURE3                       = 0x84C3;
let GL_TEXTURE4                       = 0x84C4;
let GL_TEXTURE5                       = 0x84C5;
let GL_TEXTURE6                       = 0x84C6;
let GL_TEXTURE7                       = 0x84C7;
let GL_TEXTURE8                       = 0x84C8;
let GL_TEXTURE9                       = 0x84C9;
let GL_TEXTURE10                      = 0x84CA;
let GL_TEXTURE11                      = 0x84CB;
let GL_TEXTURE12                      = 0x84CC;
let GL_TEXTURE13                      = 0x84CD;
let GL_TEXTURE14                      = 0x84CE;
let GL_TEXTURE15                      = 0x84CF;
let GL_TEXTURE16                      = 0x84D0;
let GL_TEXTURE17                      = 0x84D1;
let GL_TEXTURE18                      = 0x84D2;
let GL_TEXTURE19                      = 0x84D3;
let GL_TEXTURE20                      = 0x84D4;
let GL_TEXTURE21                      = 0x84D5;
let GL_TEXTURE22                      = 0x84D6;
let GL_TEXTURE23                      = 0x84D7;
let GL_TEXTURE24                      = 0x84D8;
let GL_TEXTURE25                      = 0x84D9;
let GL_TEXTURE26                      = 0x84DA;
let GL_TEXTURE27                      = 0x84DB;
let GL_TEXTURE28                      = 0x84DC;
let GL_TEXTURE29                      = 0x84DD;
let GL_TEXTURE30                      = 0x84DE;
let GL_TEXTURE31                      = 0x84DF;
let GL_ACTIVE_TEXTURE                 = 0x84E0;
let GL_MULTISAMPLE                    = 0x809D;
let GL_SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;
let GL_SAMPLE_ALPHA_TO_ONE            = 0x809F;
let GL_SAMPLE_COVERAGE                = 0x80A0;
let GL_SAMPLE_BUFFERS                 = 0x80A8;
let GL_SAMPLES                        = 0x80A9;
let GL_SAMPLE_COVERAGE_VALUE          = 0x80AA;
let GL_SAMPLE_COVERAGE_INVERT         = 0x80AB;
let GL_TEXTURE_CUBE_MAP               = 0x8513;
let GL_TEXTURE_BINDING_CUBE_MAP       = 0x8514;
let GL_TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
let GL_TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
let GL_TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
let GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
let GL_TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
let GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;
let GL_PROXY_TEXTURE_CUBE_MAP         = 0x851B;
let GL_MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;
let GL_COMPRESSED_RGB                 = 0x84ED;
let GL_COMPRESSED_RGBA                = 0x84EE;
let GL_TEXTURE_COMPRESSION_HINT       = 0x84EF;
let GL_TEXTURE_COMPRESSED_IMAGE_SIZE  = 0x86A0;
let GL_TEXTURE_COMPRESSED             = 0x86A1;
let GL_NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
let GL_COMPRESSED_TEXTURE_FORMATS     = 0x86A3;
let GL_CLAMP_TO_BORDER                = 0x812D;
let GL_BLEND_DST_RGB                  = 0x80C8;
let GL_BLEND_SRC_RGB                  = 0x80C9;
let GL_BLEND_DST_ALPHA                = 0x80CA;
let GL_BLEND_SRC_ALPHA                = 0x80CB;
let GL_POINT_FADE_THRESHOLD_SIZE      = 0x8128;
let GL_DEPTH_COMPONENT16              = 0x81A5;
let GL_DEPTH_COMPONENT24              = 0x81A6;
let GL_DEPTH_COMPONENT32              = 0x81A7;
let GL_MIRRORED_REPEAT                = 0x8370;
let GL_MAX_TEXTURE_LOD_BIAS           = 0x84FD;
let GL_TEXTURE_LOD_BIAS               = 0x8501;
let GL_INCR_WRAP                      = 0x8507;
let GL_DECR_WRAP                      = 0x8508;
let GL_TEXTURE_DEPTH_SIZE             = 0x884A;
let GL_TEXTURE_COMPARE_MODE           = 0x884C;
let GL_TEXTURE_COMPARE_FUNC           = 0x884D;
let GL_FUNC_ADD                       = 0x8006;
let GL_FUNC_SUBTRACT                  = 0x800A;
let GL_FUNC_REVERSE_SUBTRACT          = 0x800B;
let GL_MIN                            = 0x8007;
let GL_MAX                            = 0x8008;
let GL_CONSTANT_COLOR                 = 0x8001;
let GL_ONE_MINUS_CONSTANT_COLOR       = 0x8002;
let GL_CONSTANT_ALPHA                 = 0x8003;
let GL_ONE_MINUS_CONSTANT_ALPHA       = 0x8004;
let GL_BUFFER_SIZE                    = 0x8764;
let GL_BUFFER_USAGE                   = 0x8765;
let GL_QUERY_COUNTER_BITS             = 0x8864;
let GL_CURRENT_QUERY                  = 0x8865;
let GL_QUERY_RESULT                   = 0x8866;
let GL_QUERY_RESULT_AVAILABLE         = 0x8867;
let GL_ARRAY_BUFFER                   = 0x8892;
let GL_ELEMENT_ARRAY_BUFFER           = 0x8893;
let GL_ARRAY_BUFFER_BINDING           = 0x8894;
let GL_ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;
let GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
let GL_READ_ONLY                      = 0x88B8;
let GL_WRITE_ONLY                     = 0x88B9;
let GL_READ_WRITE                     = 0x88BA;
let GL_BUFFER_ACCESS                  = 0x88BB;
let GL_BUFFER_MAPPED                  = 0x88BC;
let GL_BUFFER_MAP_POINTER             = 0x88BD;
let GL_STREAM_DRAW                    = 0x88E0;
let GL_STREAM_READ                    = 0x88E1;
let GL_STREAM_COPY                    = 0x88E2;
let GL_STATIC_DRAW                    = 0x88E4;
let GL_STATIC_READ                    = 0x88E5;
let GL_STATIC_COPY                    = 0x88E6;
let GL_DYNAMIC_DRAW                   = 0x88E8;
let GL_DYNAMIC_READ                   = 0x88E9;
let GL_DYNAMIC_COPY                   = 0x88EA;
let GL_SAMPLES_PASSED                 = 0x8914;
let GL_SRC1_ALPHA                     = 0x8589;
let GL_BLEND_EQUATION_RGB             = 0x8009;
let GL_VERTEX_ATTRIB_ARRAY_ENABLED    = 0x8622;
let GL_VERTEX_ATTRIB_ARRAY_SIZE       = 0x8623;
let GL_VERTEX_ATTRIB_ARRAY_STRIDE     = 0x8624;
let GL_VERTEX_ATTRIB_ARRAY_TYPE       = 0x8625;
let GL_CURRENT_VERTEX_ATTRIB          = 0x8626;
let GL_VERTEX_PROGRAM_POINT_SIZE      = 0x8642;
let GL_VERTEX_ATTRIB_ARRAY_POINTER    = 0x8645;
let GL_STENCIL_BACK_FUNC              = 0x8800;
let GL_STENCIL_BACK_FAIL              = 0x8801;
let GL_STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;
let GL_STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;
let GL_MAX_DRAW_BUFFERS               = 0x8824;
let GL_DRAW_BUFFER0                   = 0x8825;
let GL_DRAW_BUFFER1                   = 0x8826;
let GL_DRAW_BUFFER2                   = 0x8827;
let GL_DRAW_BUFFER3                   = 0x8828;
let GL_DRAW_BUFFER4                   = 0x8829;
let GL_DRAW_BUFFER5                   = 0x882A;
let GL_DRAW_BUFFER6                   = 0x882B;
let GL_DRAW_BUFFER7                   = 0x882C;
let GL_DRAW_BUFFER8                   = 0x882D;
let GL_DRAW_BUFFER9                   = 0x882E;
let GL_DRAW_BUFFER10                  = 0x882F;
let GL_DRAW_BUFFER11                  = 0x8830;
let GL_DRAW_BUFFER12                  = 0x8831;
let GL_DRAW_BUFFER13                  = 0x8832;
let GL_DRAW_BUFFER14                  = 0x8833;
let GL_DRAW_BUFFER15                  = 0x8834;
let GL_BLEND_EQUATION_ALPHA           = 0x883D;
let GL_MAX_VERTEX_ATTRIBS             = 0x8869;
let GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
let GL_MAX_TEXTURE_IMAGE_UNITS        = 0x8872;
let GL_FRAGMENT_SHADER                = 0x8B30;
let GL_VERTEX_SHADER                  = 0x8B31;
let GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49;
let GL_MAX_VERTEX_UNIFORM_COMPONENTS  = 0x8B4A;
let GL_MAX_VARYING_FLOATS             = 0x8B4B;
let GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
let GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
let GL_SHADER_TYPE                    = 0x8B4F;
let GL_FLOAT_VEC2                     = 0x8B50;
let GL_FLOAT_VEC3                     = 0x8B51;
let GL_FLOAT_VEC4                     = 0x8B52;
let GL_INT_VEC2                       = 0x8B53;
let GL_INT_VEC3                       = 0x8B54;
let GL_INT_VEC4                       = 0x8B55;
let GL_BOOL                           = 0x8B56;
let GL_BOOL_VEC2                      = 0x8B57;
let GL_BOOL_VEC3                      = 0x8B58;
let GL_BOOL_VEC4                      = 0x8B59;
let GL_FLOAT_MAT2                     = 0x8B5A;
let GL_FLOAT_MAT3                     = 0x8B5B;
let GL_FLOAT_MAT4                     = 0x8B5C;
let GL_SAMPLER_1D                     = 0x8B5D;
let GL_SAMPLER_2D                     = 0x8B5E;
let GL_SAMPLER_3D                     = 0x8B5F;
let GL_SAMPLER_CUBE                   = 0x8B60;
let GL_SAMPLER_1D_SHADOW              = 0x8B61;
let GL_SAMPLER_2D_SHADOW              = 0x8B62;
let GL_DELETE_STATUS                  = 0x8B80;
let GL_COMPILE_STATUS                 = 0x8B81;
let GL_LINK_STATUS                    = 0x8B82;
let GL_VALIDATE_STATUS                = 0x8B83;
let GL_INFO_LOG_LENGTH                = 0x8B84;
let GL_ATTACHED_SHADERS               = 0x8B85;
let GL_ACTIVE_UNIFORMS                = 0x8B86;
let GL_ACTIVE_UNIFORM_MAX_LENGTH      = 0x8B87;
let GL_SHADER_SOURCE_LENGTH           = 0x8B88;
let GL_ACTIVE_ATTRIBUTES              = 0x8B89;
let GL_ACTIVE_ATTRIBUTE_MAX_LENGTH    = 0x8B8A;
let GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B;
let GL_SHADING_LANGUAGE_VERSION       = 0x8B8C;
let GL_CURRENT_PROGRAM                = 0x8B8D;
let GL_POINT_SPRITE_COORD_ORIGIN      = 0x8CA0;
let GL_LOWER_LEFT                     = 0x8CA1;
let GL_UPPER_LEFT                     = 0x8CA2;
let GL_STENCIL_BACK_REF               = 0x8CA3;
let GL_STENCIL_BACK_VALUE_MASK        = 0x8CA4;
let GL_STENCIL_BACK_WRITEMASK         = 0x8CA5;
let GL_PIXEL_PACK_BUFFER              = 0x88EB;
let GL_PIXEL_UNPACK_BUFFER            = 0x88EC;
let GL_PIXEL_PACK_BUFFER_BINDING      = 0x88ED;
let GL_PIXEL_UNPACK_BUFFER_BINDING    = 0x88EF;
let GL_FLOAT_MAT2x3                   = 0x8B65;
let GL_FLOAT_MAT2x4                   = 0x8B66;
let GL_FLOAT_MAT3x2                   = 0x8B67;
let GL_FLOAT_MAT3x4                   = 0x8B68;
let GL_FLOAT_MAT4x2                   = 0x8B69;
let GL_FLOAT_MAT4x3                   = 0x8B6A;
let GL_SRGB                           = 0x8C40;
let GL_SRGB8                          = 0x8C41;
let GL_SRGB_ALPHA                     = 0x8C42;
let GL_SRGB8_ALPHA8                   = 0x8C43;
let GL_COMPRESSED_SRGB                = 0x8C48;
let GL_COMPRESSED_SRGB_ALPHA          = 0x8C49;
let GL_COMPARE_REF_TO_TEXTURE         = 0x884E;
let GL_CLIP_DISTANCE0                 = 0x3000;
let GL_CLIP_DISTANCE1                 = 0x3001;
let GL_CLIP_DISTANCE2                 = 0x3002;
let GL_CLIP_DISTANCE3                 = 0x3003;
let GL_CLIP_DISTANCE4                 = 0x3004;
let GL_CLIP_DISTANCE5                 = 0x3005;
let GL_CLIP_DISTANCE6                 = 0x3006;
let GL_CLIP_DISTANCE7                 = 0x3007;
let GL_MAX_CLIP_DISTANCES             = 0x0D32;
let GL_MAJOR_VERSION                  = 0x821B;
let GL_MINOR_VERSION                  = 0x821C;
let GL_NUM_EXTENSIONS                 = 0x821D;
let GL_CONTEXT_FLAGS                  = 0x821E;
let GL_COMPRESSED_RED                 = 0x8225;
let GL_COMPRESSED_RG                  = 0x8226;
let GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001;
let GL_RGBA32F                        = 0x8814;
let GL_RGB32F                         = 0x8815;
let GL_RGBA16F                        = 0x881A;
let GL_RGB16F                         = 0x881B;
let GL_VERTEX_ATTRIB_ARRAY_INTEGER    = 0x88FD;
let GL_MAX_ARRAY_TEXTURE_LAYERS       = 0x88FF;
let GL_MIN_PROGRAM_TEXEL_OFFSET       = 0x8904;
let GL_MAX_PROGRAM_TEXEL_OFFSET       = 0x8905;
let GL_CLAMP_READ_COLOR               = 0x891C;
let GL_FIXED_ONLY                     = 0x891D;
let GL_MAX_VARYING_COMPONENTS         = 0x8B4B;
let GL_TEXTURE_1D_ARRAY               = 0x8C18;
let GL_PROXY_TEXTURE_1D_ARRAY         = 0x8C19;
let GL_TEXTURE_2D_ARRAY               = 0x8C1A;
let GL_PROXY_TEXTURE_2D_ARRAY         = 0x8C1B;
let GL_TEXTURE_BINDING_1D_ARRAY       = 0x8C1C;
let GL_TEXTURE_BINDING_2D_ARRAY       = 0x8C1D;
let GL_R11F_G11F_B10F                 = 0x8C3A;
let GL_UNSIGNED_INT_10F_11F_11F_REV   = 0x8C3B;
let GL_RGB9_E5                        = 0x8C3D;
let GL_UNSIGNED_INT_5_9_9_9_REV       = 0x8C3E;
let GL_TEXTURE_SHARED_SIZE            = 0x8C3F;
let GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76;
let GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;
let GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80;
let GL_TRANSFORM_FEEDBACK_VARYINGS    = 0x8C83;
let GL_TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84;
let GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85;
let GL_PRIMITIVES_GENERATED           = 0x8C87;
let GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88;
let GL_RASTERIZER_DISCARD             = 0x8C89;
let GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A;
let GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B;
let GL_INTERLEAVED_ATTRIBS            = 0x8C8C;
let GL_SEPARATE_ATTRIBS               = 0x8C8D;
let GL_TRANSFORM_FEEDBACK_BUFFER      = 0x8C8E;
let GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F;
let GL_RGBA32UI                       = 0x8D70;
let GL_RGB32UI                        = 0x8D71;
let GL_RGBA16UI                       = 0x8D76;
let GL_RGB16UI                        = 0x8D77;
let GL_RGBA8UI                        = 0x8D7C;
let GL_RGB8UI                         = 0x8D7D;
let GL_RGBA32I                        = 0x8D82;
let GL_RGB32I                         = 0x8D83;
let GL_RGBA16I                        = 0x8D88;
let GL_RGB16I                         = 0x8D89;
let GL_RGBA8I                         = 0x8D8E;
let GL_RGB8I                          = 0x8D8F;
let GL_RED_INTEGER                    = 0x8D94;
let GL_GREEN_INTEGER                  = 0x8D95;
let GL_BLUE_INTEGER                   = 0x8D96;
let GL_RGB_INTEGER                    = 0x8D98;
let GL_RGBA_INTEGER                   = 0x8D99;
let GL_BGR_INTEGER                    = 0x8D9A;
let GL_BGRA_INTEGER                   = 0x8D9B;
let GL_SAMPLER_1D_ARRAY               = 0x8DC0;
let GL_SAMPLER_2D_ARRAY               = 0x8DC1;
let GL_SAMPLER_1D_ARRAY_SHADOW        = 0x8DC3;
let GL_SAMPLER_2D_ARRAY_SHADOW        = 0x8DC4;
let GL_SAMPLER_CUBE_SHADOW            = 0x8DC5;
let GL_UNSIGNED_INT_VEC2              = 0x8DC6;
let GL_UNSIGNED_INT_VEC3              = 0x8DC7;
let GL_UNSIGNED_INT_VEC4              = 0x8DC8;
let GL_INT_SAMPLER_1D                 = 0x8DC9;
let GL_INT_SAMPLER_2D                 = 0x8DCA;
let GL_INT_SAMPLER_3D                 = 0x8DCB;
let GL_INT_SAMPLER_CUBE               = 0x8DCC;
let GL_INT_SAMPLER_1D_ARRAY           = 0x8DCE;
let GL_INT_SAMPLER_2D_ARRAY           = 0x8DCF;
let GL_UNSIGNED_INT_SAMPLER_1D        = 0x8DD1;
let GL_UNSIGNED_INT_SAMPLER_2D        = 0x8DD2;
let GL_UNSIGNED_INT_SAMPLER_3D        = 0x8DD3;
let GL_UNSIGNED_INT_SAMPLER_CUBE      = 0x8DD4;
let GL_UNSIGNED_INT_SAMPLER_1D_ARRAY  = 0x8DD6;
let GL_UNSIGNED_INT_SAMPLER_2D_ARRAY  = 0x8DD7;
let GL_QUERY_WAIT                     = 0x8E13;
let GL_QUERY_NO_WAIT                  = 0x8E14;
let GL_QUERY_BY_REGION_WAIT           = 0x8E15;
let GL_QUERY_BY_REGION_NO_WAIT        = 0x8E16;
let GL_BUFFER_ACCESS_FLAGS            = 0x911F;
let GL_BUFFER_MAP_LENGTH              = 0x9120;
let GL_BUFFER_MAP_OFFSET              = 0x9121;
let GL_DEPTH_COMPONENT32F             = 0x8CAC;
let GL_DEPTH32F_STENCIL8              = 0x8CAD;
let GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
let GL_INVALID_FRAMEBUFFER_OPERATION  = 0x0506;
let GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210;
let GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211;
let GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212;
let GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213;
let GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214;
let GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215;
let GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216;
let GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217;
let GL_FRAMEBUFFER_DEFAULT            = 0x8218;
let GL_FRAMEBUFFER_UNDEFINED          = 0x8219;
let GL_DEPTH_STENCIL_ATTACHMENT       = 0x821A;
let GL_MAX_RENDERBUFFER_SIZE          = 0x84E8;
let GL_DEPTH_STENCIL                  = 0x84F9;
let GL_UNSIGNED_INT_24_8              = 0x84FA;
let GL_DEPTH24_STENCIL8               = 0x88F0;
let GL_TEXTURE_STENCIL_SIZE           = 0x88F1;
let GL_TEXTURE_RED_TYPE               = 0x8C10;
let GL_TEXTURE_GREEN_TYPE             = 0x8C11;
let GL_TEXTURE_BLUE_TYPE              = 0x8C12;
let GL_TEXTURE_ALPHA_TYPE             = 0x8C13;
let GL_TEXTURE_DEPTH_TYPE             = 0x8C16;
let GL_UNSIGNED_NORMALIZED            = 0x8C17;
let GL_FRAMEBUFFER_BINDING            = 0x8CA6;
let GL_DRAW_FRAMEBUFFER_BINDING       = 0x8CA6;
let GL_RENDERBUFFER_BINDING           = 0x8CA7;
let GL_READ_FRAMEBUFFER               = 0x8CA8;
let GL_DRAW_FRAMEBUFFER               = 0x8CA9;
let GL_READ_FRAMEBUFFER_BINDING       = 0x8CAA;
let GL_RENDERBUFFER_SAMPLES           = 0x8CAB;
let GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
let GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
let GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
let GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
let GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4;
let GL_FRAMEBUFFER_COMPLETE           = 0x8CD5;
let GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
let GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
let GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 0x8CDB;
let GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 0x8CDC;
let GL_FRAMEBUFFER_UNSUPPORTED        = 0x8CDD;
let GL_MAX_COLOR_ATTACHMENTS          = 0x8CDF;
let GL_COLOR_ATTACHMENT0              = 0x8CE0;
let GL_COLOR_ATTACHMENT1              = 0x8CE1;
let GL_COLOR_ATTACHMENT2              = 0x8CE2;
let GL_COLOR_ATTACHMENT3              = 0x8CE3;
let GL_COLOR_ATTACHMENT4              = 0x8CE4;
let GL_COLOR_ATTACHMENT5              = 0x8CE5;
let GL_COLOR_ATTACHMENT6              = 0x8CE6;
let GL_COLOR_ATTACHMENT7              = 0x8CE7;
let GL_COLOR_ATTACHMENT8              = 0x8CE8;
let GL_COLOR_ATTACHMENT9              = 0x8CE9;
let GL_COLOR_ATTACHMENT10             = 0x8CEA;
let GL_COLOR_ATTACHMENT11             = 0x8CEB;
let GL_COLOR_ATTACHMENT12             = 0x8CEC;
let GL_COLOR_ATTACHMENT13             = 0x8CED;
let GL_COLOR_ATTACHMENT14             = 0x8CEE;
let GL_COLOR_ATTACHMENT15             = 0x8CEF;
let GL_COLOR_ATTACHMENT16             = 0x8CF0;
let GL_COLOR_ATTACHMENT17             = 0x8CF1;
let GL_COLOR_ATTACHMENT18             = 0x8CF2;
let GL_COLOR_ATTACHMENT19             = 0x8CF3;
let GL_COLOR_ATTACHMENT20             = 0x8CF4;
let GL_COLOR_ATTACHMENT21             = 0x8CF5;
let GL_COLOR_ATTACHMENT22             = 0x8CF6;
let GL_COLOR_ATTACHMENT23             = 0x8CF7;
let GL_COLOR_ATTACHMENT24             = 0x8CF8;
let GL_COLOR_ATTACHMENT25             = 0x8CF9;
let GL_COLOR_ATTACHMENT26             = 0x8CFA;
let GL_COLOR_ATTACHMENT27             = 0x8CFB;
let GL_COLOR_ATTACHMENT28             = 0x8CFC;
let GL_COLOR_ATTACHMENT29             = 0x8CFD;
let GL_COLOR_ATTACHMENT30             = 0x8CFE;
let GL_COLOR_ATTACHMENT31             = 0x8CFF;
let GL_DEPTH_ATTACHMENT               = 0x8D00;
let GL_STENCIL_ATTACHMENT             = 0x8D20;
let GL_FRAMEBUFFER                    = 0x8D40;
let GL_RENDERBUFFER                   = 0x8D41;
let GL_RENDERBUFFER_WIDTH             = 0x8D42;
let GL_RENDERBUFFER_HEIGHT            = 0x8D43;
let GL_RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;
let GL_STENCIL_INDEX1                 = 0x8D46;
let GL_STENCIL_INDEX4                 = 0x8D47;
let GL_STENCIL_INDEX8                 = 0x8D48;
let GL_STENCIL_INDEX16                = 0x8D49;
let GL_RENDERBUFFER_RED_SIZE          = 0x8D50;
let GL_RENDERBUFFER_GREEN_SIZE        = 0x8D51;
let GL_RENDERBUFFER_BLUE_SIZE         = 0x8D52;
let GL_RENDERBUFFER_ALPHA_SIZE        = 0x8D53;
let GL_RENDERBUFFER_DEPTH_SIZE        = 0x8D54;
let GL_RENDERBUFFER_STENCIL_SIZE      = 0x8D55;
let GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56;
let GL_MAX_SAMPLES                    = 0x8D57;
let GL_FRAMEBUFFER_SRGB               = 0x8DB9;
let GL_HALF_FLOAT                     = 0x140B;
let GL_MAP_READ_BIT                   = 0x0001;
let GL_MAP_WRITE_BIT                  = 0x0002;
let GL_MAP_INVALIDATE_RANGE_BIT       = 0x0004;
let GL_MAP_INVALIDATE_BUFFER_BIT      = 0x0008;
let GL_MAP_FLUSH_EXPLICIT_BIT         = 0x0010;
let GL_MAP_UNSYNCHRONIZED_BIT         = 0x0020;
let GL_COMPRESSED_RED_RGTC1           = 0x8DBB;
let GL_COMPRESSED_SIGNED_RED_RGTC1    = 0x8DBC;
let GL_COMPRESSED_RG_RGTC2            = 0x8DBD;
let GL_COMPRESSED_SIGNED_RG_RGTC2     = 0x8DBE;
let GL_RG                             = 0x8227;
let GL_RG_INTEGER                     = 0x8228;
let GL_R8                             = 0x8229;
let GL_R16                            = 0x822A;
let GL_RG8                            = 0x822B;
let GL_RG16                           = 0x822C;
let GL_R16F                           = 0x822D;
let GL_R32F                           = 0x822E;
let GL_RG16F                          = 0x822F;
let GL_RG32F                          = 0x8230;
let GL_R8I                            = 0x8231;
let GL_R8UI                           = 0x8232;
let GL_R16I                           = 0x8233;
let GL_R16UI                          = 0x8234;
let GL_R32I                           = 0x8235;
let GL_R32UI                          = 0x8236;
let GL_RG8I                           = 0x8237;
let GL_RG8UI                          = 0x8238;
let GL_RG16I                          = 0x8239;
let GL_RG16UI                         = 0x823A;
let GL_RG32I                          = 0x823B;
let GL_RG32UI                         = 0x823C;
let GL_VERTEX_ARRAY_BINDING           = 0x85B5;
let GL_SAMPLER_2D_RECT                = 0x8B63;
let GL_SAMPLER_2D_RECT_SHADOW         = 0x8B64;
let GL_SAMPLER_BUFFER                 = 0x8DC2;
let GL_INT_SAMPLER_2D_RECT            = 0x8DCD;
let GL_INT_SAMPLER_BUFFER             = 0x8DD0;
let GL_UNSIGNED_INT_SAMPLER_2D_RECT   = 0x8DD5;
let GL_UNSIGNED_INT_SAMPLER_BUFFER    = 0x8DD8;
let GL_TEXTURE_BUFFER                 = 0x8C2A;
let GL_MAX_TEXTURE_BUFFER_SIZE        = 0x8C2B;
let GL_TEXTURE_BINDING_BUFFER         = 0x8C2C;
let GL_TEXTURE_BUFFER_DATA_STORE_BINDING = 0x8C2D;
let GL_TEXTURE_RECTANGLE              = 0x84F5;
let GL_TEXTURE_BINDING_RECTANGLE      = 0x84F6;
let GL_PROXY_TEXTURE_RECTANGLE        = 0x84F7;
let GL_MAX_RECTANGLE_TEXTURE_SIZE     = 0x84F8;
let GL_R8_SNORM                       = 0x8F94;
let GL_RG8_SNORM                      = 0x8F95;
let GL_RGB8_SNORM                     = 0x8F96;
let GL_RGBA8_SNORM                    = 0x8F97;
let GL_R16_SNORM                      = 0x8F98;
let GL_RG16_SNORM                     = 0x8F99;
let GL_RGB16_SNORM                    = 0x8F9A;
let GL_RGBA16_SNORM                   = 0x8F9B;
let GL_SIGNED_NORMALIZED              = 0x8F9C;
let GL_PRIMITIVE_RESTART              = 0x8F9D;
let GL_PRIMITIVE_RESTART_INDEX        = 0x8F9E;
let GL_COPY_READ_BUFFER               = 0x8F36;
let GL_COPY_WRITE_BUFFER              = 0x8F37;
let GL_UNIFORM_BUFFER                 = 0x8A11;
let GL_UNIFORM_BUFFER_BINDING         = 0x8A28;
let GL_UNIFORM_BUFFER_START           = 0x8A29;
let GL_UNIFORM_BUFFER_SIZE            = 0x8A2A;
let GL_MAX_VERTEX_UNIFORM_BLOCKS      = 0x8A2B;
let GL_MAX_GEOMETRY_UNIFORM_BLOCKS    = 0x8A2C;
let GL_MAX_FRAGMENT_UNIFORM_BLOCKS    = 0x8A2D;
let GL_MAX_COMBINED_UNIFORM_BLOCKS    = 0x8A2E;
let GL_MAX_UNIFORM_BUFFER_BINDINGS    = 0x8A2F;
let GL_MAX_UNIFORM_BLOCK_SIZE         = 0x8A30;
let GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31;
let GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32;
let GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33;
let GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34;
let GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35;
let GL_ACTIVE_UNIFORM_BLOCKS          = 0x8A36;
let GL_UNIFORM_TYPE                   = 0x8A37;
let GL_UNIFORM_SIZE                   = 0x8A38;
let GL_UNIFORM_NAME_LENGTH            = 0x8A39;
let GL_UNIFORM_BLOCK_INDEX            = 0x8A3A;
let GL_UNIFORM_OFFSET                 = 0x8A3B;
let GL_UNIFORM_ARRAY_STRIDE           = 0x8A3C;
let GL_UNIFORM_MATRIX_STRIDE          = 0x8A3D;
let GL_UNIFORM_IS_ROW_MAJOR           = 0x8A3E;
let GL_UNIFORM_BLOCK_BINDING          = 0x8A3F;
let GL_UNIFORM_BLOCK_DATA_SIZE        = 0x8A40;
let GL_UNIFORM_BLOCK_NAME_LENGTH      = 0x8A41;
let GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS  = 0x8A42;
let GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43;
let GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44;
let GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = 0x8A45;
let GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46;
let GL_INVALID_INDEX                  = 0xFFFFFFFF;
let GL_CONTEXT_CORE_PROFILE_BIT       = 0x00000001;
let GL_CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002;
let GL_LINES_ADJACENCY                = 0x000A;
let GL_LINE_STRIP_ADJACENCY           = 0x000B;
let GL_TRIANGLES_ADJACENCY            = 0x000C;
let GL_TRIANGLE_STRIP_ADJACENCY       = 0x000D;
let GL_PROGRAM_POINT_SIZE             = 0x8642;
let GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29;
let GL_FRAMEBUFFER_ATTACHMENT_LAYERED = 0x8DA7;
let GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8;
let GL_GEOMETRY_SHADER                = 0x8DD9;
let GL_GEOMETRY_VERTICES_OUT          = 0x8916;
let GL_GEOMETRY_INPUT_TYPE            = 0x8917;
let GL_GEOMETRY_OUTPUT_TYPE           = 0x8918;
let GL_MAX_GEOMETRY_UNIFORM_COMPONENTS = 0x8DDF;
let GL_MAX_GEOMETRY_OUTPUT_VERTICES   = 0x8DE0;
let GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1;
let GL_MAX_VERTEX_OUTPUT_COMPONENTS   = 0x9122;
let GL_MAX_GEOMETRY_INPUT_COMPONENTS  = 0x9123;
let GL_MAX_GEOMETRY_OUTPUT_COMPONENTS = 0x9124;
let GL_MAX_FRAGMENT_INPUT_COMPONENTS  = 0x9125;
let GL_CONTEXT_PROFILE_MASK           = 0x9126;
let GL_DEPTH_CLAMP                    = 0x864F;
let GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C;
let GL_FIRST_VERTEX_CONVENTION        = 0x8E4D;
let GL_LAST_VERTEX_CONVENTION         = 0x8E4E;
let GL_PROVOKING_VERTEX               = 0x8E4F;
let GL_TEXTURE_CUBE_MAP_SEAMLESS      = 0x884F;
let GL_MAX_SERVER_WAIT_TIMEOUT        = 0x9111;
let GL_OBJECT_TYPE                    = 0x9112;
let GL_SYNC_CONDITION                 = 0x9113;
let GL_SYNC_STATUS                    = 0x9114;
let GL_SYNC_FLAGS                     = 0x9115;
let GL_SYNC_FENCE                     = 0x9116;
let GL_SYNC_GPU_COMMANDS_COMPLETE     = 0x9117;
let GL_UNSIGNALED                     = 0x9118;
let GL_SIGNALED                       = 0x9119;
let GL_ALREADY_SIGNALED               = 0x911A;
let GL_TIMEOUT_EXPIRED                = 0x911B;
let GL_CONDITION_SATISFIED            = 0x911C;
let GL_WAIT_FAILED                    = 0x911D;
let GL_TIMEOUT_IGNORED                = 0xFFFFFFFFFFFFFFFF;
let GL_SYNC_FLUSH_COMMANDS_BIT        = 0x00000001;
let GL_SAMPLE_POSITION                = 0x8E50;
let GL_SAMPLE_MASK                    = 0x8E51;
let GL_SAMPLE_MASK_VALUE              = 0x8E52;
let GL_MAX_SAMPLE_MASK_WORDS          = 0x8E59;
let GL_TEXTURE_2D_MULTISAMPLE         = 0x9100;
let GL_PROXY_TEXTURE_2D_MULTISAMPLE   = 0x9101;
let GL_TEXTURE_2D_MULTISAMPLE_ARRAY   = 0x9102;
let GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103;
let GL_TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104;
let GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105;
let GL_TEXTURE_SAMPLES                = 0x9106;
let GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107;
let GL_SAMPLER_2D_MULTISAMPLE         = 0x9108;
let GL_INT_SAMPLER_2D_MULTISAMPLE     = 0x9109;
let GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A;
let GL_SAMPLER_2D_MULTISAMPLE_ARRAY   = 0x910B;
let GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C;
let GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D;
let GL_MAX_COLOR_TEXTURE_SAMPLES      = 0x910E;
let GL_MAX_DEPTH_TEXTURE_SAMPLES      = 0x910F;
let GL_MAX_INTEGER_SAMPLES            = 0x9110;
let GL_VERTEX_ATTRIB_ARRAY_DIVISOR    = 0x88FE;
let GL_SRC1_COLOR                     = 0x88F9;
let GL_ONE_MINUS_SRC1_COLOR           = 0x88FA;
let GL_ONE_MINUS_SRC1_ALPHA           = 0x88FB;
let GL_MAX_DUAL_SOURCE_DRAW_BUFFERS   = 0x88FC;
let GL_ANY_SAMPLES_PASSED             = 0x8C2F;
let GL_SAMPLER_BINDING                = 0x8919;
let GL_RGB10_A2UI                     = 0x906F;
let GL_TEXTURE_SWIZZLE_R              = 0x8E42;
let GL_TEXTURE_SWIZZLE_G              = 0x8E43;
let GL_TEXTURE_SWIZZLE_B              = 0x8E44;
let GL_TEXTURE_SWIZZLE_A              = 0x8E45;
let GL_TEXTURE_SWIZZLE_RGBA           = 0x8E46;
let GL_TIME_ELAPSED                   = 0x88BF;
let GL_TIMESTAMP                      = 0x8E28;
let GL_INT_2_10_10_10_REV             = 0x8D9F;
let GL_SAMPLE_SHADING                 = 0x8C36;
let GL_MIN_SAMPLE_SHADING_VALUE       = 0x8C37;
let GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5E;
let GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5F;
let GL_TEXTURE_CUBE_MAP_ARRAY         = 0x9009;
let GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = 0x900A;
let GL_PROXY_TEXTURE_CUBE_MAP_ARRAY   = 0x900B;
let GL_SAMPLER_CUBE_MAP_ARRAY         = 0x900C;
let GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW  = 0x900D;
let GL_INT_SAMPLER_CUBE_MAP_ARRAY     = 0x900E;
let GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900F;
let GL_DRAW_INDIRECT_BUFFER           = 0x8F3F;
let GL_DRAW_INDIRECT_BUFFER_BINDING   = 0x8F43;
let GL_GEOMETRY_SHADER_INVOCATIONS    = 0x887F;
let GL_MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A;
let GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B;
let GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C;
let GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D;
let GL_MAX_VERTEX_STREAMS             = 0x8E71;
let GL_DOUBLE_VEC2                    = 0x8FFC;
let GL_DOUBLE_VEC3                    = 0x8FFD;
let GL_DOUBLE_VEC4                    = 0x8FFE;
let GL_DOUBLE_MAT2                    = 0x8F46;
let GL_DOUBLE_MAT3                    = 0x8F47;
let GL_DOUBLE_MAT4                    = 0x8F48;
let GL_DOUBLE_MAT2x3                  = 0x8F49;
let GL_DOUBLE_MAT2x4                  = 0x8F4A;
let GL_DOUBLE_MAT3x2                  = 0x8F4B;
let GL_DOUBLE_MAT3x4                  = 0x8F4C;
let GL_DOUBLE_MAT4x2                  = 0x8F4D;
let GL_DOUBLE_MAT4x3                  = 0x8F4E;
let GL_ACTIVE_SUBROUTINES             = 0x8DE5;
let GL_ACTIVE_SUBROUTINE_UNIFORMS     = 0x8DE6;
let GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47;
let GL_ACTIVE_SUBROUTINE_MAX_LENGTH   = 0x8E48;
let GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49;
let GL_MAX_SUBROUTINES                = 0x8DE7;
let GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8;
let GL_NUM_COMPATIBLE_SUBROUTINES     = 0x8E4A;
let GL_COMPATIBLE_SUBROUTINES         = 0x8E4B;
let GL_PATCHES                        = 0x000E;
let GL_PATCH_VERTICES                 = 0x8E72;
let GL_PATCH_DEFAULT_INNER_LEVEL      = 0x8E73;
let GL_PATCH_DEFAULT_OUTER_LEVEL      = 0x8E74;
let GL_TESS_CONTROL_OUTPUT_VERTICES   = 0x8E75;
let GL_TESS_GEN_MODE                  = 0x8E76;
let GL_TESS_GEN_SPACING               = 0x8E77;
let GL_TESS_GEN_VERTEX_ORDER          = 0x8E78;
let GL_TESS_GEN_POINT_MODE            = 0x8E79;
let GL_ISOLINES                       = 0x8E7A;
let GL_FRACTIONAL_ODD                 = 0x8E7B;
let GL_FRACTIONAL_EVEN                = 0x8E7C;
let GL_MAX_PATCH_VERTICES             = 0x8E7D;
let GL_MAX_TESS_GEN_LEVEL             = 0x8E7E;
let GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F;
let GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80;
let GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81;
let GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82;
let GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83;
let GL_MAX_TESS_PATCH_COMPONENTS      = 0x8E84;
let GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85;
let GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86;
let GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89;
let GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A;
let GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C;
let GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D;
let GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E;
let GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F;
let GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0;
let GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1;
let GL_TESS_EVALUATION_SHADER         = 0x8E87;
let GL_TESS_CONTROL_SHADER            = 0x8E88;
let GL_TRANSFORM_FEEDBACK             = 0x8E22;
let GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23;
let GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24;
let GL_TRANSFORM_FEEDBACK_BINDING     = 0x8E25;
let GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70;
let GL_FIXED                          = 0x140C;
let GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A;
let GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
let GL_LOW_FLOAT                      = 0x8DF0;
let GL_MEDIUM_FLOAT                   = 0x8DF1;
let GL_HIGH_FLOAT                     = 0x8DF2;
let GL_LOW_INT                        = 0x8DF3;
let GL_MEDIUM_INT                     = 0x8DF4;
let GL_HIGH_INT                       = 0x8DF5;
let GL_SHADER_COMPILER                = 0x8DFA;
let GL_SHADER_BINARY_FORMATS          = 0x8DF8;
let GL_NUM_SHADER_BINARY_FORMATS      = 0x8DF9;
let GL_MAX_VERTEX_UNIFORM_VECTORS     = 0x8DFB;
let GL_MAX_VARYING_VECTORS            = 0x8DFC;
let GL_MAX_FRAGMENT_UNIFORM_VECTORS   = 0x8DFD;
let GL_RGB565                         = 0x8D62;
let GL_PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257;
let GL_PROGRAM_BINARY_LENGTH          = 0x8741;
let GL_NUM_PROGRAM_BINARY_FORMATS     = 0x87FE;
let GL_PROGRAM_BINARY_FORMATS         = 0x87FF;
let GL_VERTEX_SHADER_BIT              = 0x00000001;
let GL_FRAGMENT_SHADER_BIT            = 0x00000002;
let GL_GEOMETRY_SHADER_BIT            = 0x00000004;
let GL_TESS_CONTROL_SHADER_BIT        = 0x00000008;
let GL_TESS_EVALUATION_SHADER_BIT     = 0x00000010;
let GL_ALL_SHADER_BITS                = 0xFFFFFFFF;
let GL_PROGRAM_SEPARABLE              = 0x8258;
let GL_ACTIVE_PROGRAM                 = 0x8259;
let GL_PROGRAM_PIPELINE_BINDING       = 0x825A;
let GL_MAX_VIEWPORTS                  = 0x825B;
let GL_VIEWPORT_SUBPIXEL_BITS         = 0x825C;
let GL_VIEWPORT_BOUNDS_RANGE          = 0x825D;
let GL_LAYER_PROVOKING_VERTEX         = 0x825E;
let GL_VIEWPORT_INDEX_PROVOKING_VERTEX = 0x825F;
let GL_UNDEFINED_VERTEX               = 0x8260;
let GL_COPY_READ_BUFFER_BINDING       = 0x8F36;
let GL_COPY_WRITE_BUFFER_BINDING      = 0x8F37;
let GL_TRANSFORM_FEEDBACK_ACTIVE      = 0x8E24;
let GL_TRANSFORM_FEEDBACK_PAUSED      = 0x8E23;
let GL_UNPACK_COMPRESSED_BLOCK_WIDTH  = 0x9127;
let GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128;
let GL_UNPACK_COMPRESSED_BLOCK_DEPTH  = 0x9129;
let GL_UNPACK_COMPRESSED_BLOCK_SIZE   = 0x912A;
let GL_PACK_COMPRESSED_BLOCK_WIDTH    = 0x912B;
let GL_PACK_COMPRESSED_BLOCK_HEIGHT   = 0x912C;
let GL_PACK_COMPRESSED_BLOCK_DEPTH    = 0x912D;
let GL_PACK_COMPRESSED_BLOCK_SIZE     = 0x912E;
let GL_NUM_SAMPLE_COUNTS              = 0x9380;
let GL_MIN_MAP_BUFFER_ALIGNMENT       = 0x90BC;
let GL_ATOMIC_COUNTER_BUFFER          = 0x92C0;
let GL_ATOMIC_COUNTER_BUFFER_BINDING  = 0x92C1;
let GL_ATOMIC_COUNTER_BUFFER_START    = 0x92C2;
let GL_ATOMIC_COUNTER_BUFFER_SIZE     = 0x92C3;
let GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4;
let GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5;
let GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6;
let GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7;
let GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8;
let GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9;
let GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA;
let GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB;
let GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC;
let GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD;
let GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE;
let GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF;
let GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0;
let GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1;
let GL_MAX_VERTEX_ATOMIC_COUNTERS     = 0x92D2;
let GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3;
let GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4;
let GL_MAX_GEOMETRY_ATOMIC_COUNTERS   = 0x92D5;
let GL_MAX_FRAGMENT_ATOMIC_COUNTERS   = 0x92D6;
let GL_MAX_COMBINED_ATOMIC_COUNTERS   = 0x92D7;
let GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8;
let GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC;
let GL_ACTIVE_ATOMIC_COUNTER_BUFFERS  = 0x92D9;
let GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA;
let GL_UNSIGNED_INT_ATOMIC_COUNTER    = 0x92DB;
let GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001;
let GL_ELEMENT_ARRAY_BARRIER_BIT      = 0x00000002;
let GL_UNIFORM_BARRIER_BIT            = 0x00000004;
let GL_TEXTURE_FETCH_BARRIER_BIT      = 0x00000008;
let GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020;
let GL_COMMAND_BARRIER_BIT            = 0x00000040;
let GL_PIXEL_BUFFER_BARRIER_BIT       = 0x00000080;
let GL_TEXTURE_UPDATE_BARRIER_BIT     = 0x00000100;
let GL_BUFFER_UPDATE_BARRIER_BIT      = 0x00000200;
let GL_FRAMEBUFFER_BARRIER_BIT        = 0x00000400;
let GL_TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800;
let GL_ATOMIC_COUNTER_BARRIER_BIT     = 0x00001000;
let GL_ALL_BARRIER_BITS               = 0xFFFFFFFF;
let GL_MAX_IMAGE_UNITS                = 0x8F38;
let GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39;
let GL_IMAGE_BINDING_NAME             = 0x8F3A;
let GL_IMAGE_BINDING_LEVEL            = 0x8F3B;
let GL_IMAGE_BINDING_LAYERED          = 0x8F3C;
let GL_IMAGE_BINDING_LAYER            = 0x8F3D;
let GL_IMAGE_BINDING_ACCESS           = 0x8F3E;
let GL_IMAGE_1D                       = 0x904C;
let GL_IMAGE_2D                       = 0x904D;
let GL_IMAGE_3D                       = 0x904E;
let GL_IMAGE_2D_RECT                  = 0x904F;
let GL_IMAGE_CUBE                     = 0x9050;
let GL_IMAGE_BUFFER                   = 0x9051;
let GL_IMAGE_1D_ARRAY                 = 0x9052;
let GL_IMAGE_2D_ARRAY                 = 0x9053;
let GL_IMAGE_CUBE_MAP_ARRAY           = 0x9054;
let GL_IMAGE_2D_MULTISAMPLE           = 0x9055;
let GL_IMAGE_2D_MULTISAMPLE_ARRAY     = 0x9056;
let GL_INT_IMAGE_1D                   = 0x9057;
let GL_INT_IMAGE_2D                   = 0x9058;
let GL_INT_IMAGE_3D                   = 0x9059;
let GL_INT_IMAGE_2D_RECT              = 0x905A;
let GL_INT_IMAGE_CUBE                 = 0x905B;
let GL_INT_IMAGE_BUFFER               = 0x905C;
let GL_INT_IMAGE_1D_ARRAY             = 0x905D;
let GL_INT_IMAGE_2D_ARRAY             = 0x905E;
let GL_INT_IMAGE_CUBE_MAP_ARRAY       = 0x905F;
let GL_INT_IMAGE_2D_MULTISAMPLE       = 0x9060;
let GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061;
let GL_UNSIGNED_INT_IMAGE_1D          = 0x9062;
let GL_UNSIGNED_INT_IMAGE_2D          = 0x9063;
let GL_UNSIGNED_INT_IMAGE_3D          = 0x9064;
let GL_UNSIGNED_INT_IMAGE_2D_RECT     = 0x9065;
let GL_UNSIGNED_INT_IMAGE_CUBE        = 0x9066;
let GL_UNSIGNED_INT_IMAGE_BUFFER      = 0x9067;
let GL_UNSIGNED_INT_IMAGE_1D_ARRAY    = 0x9068;
let GL_UNSIGNED_INT_IMAGE_2D_ARRAY    = 0x9069;
let GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A;
let GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B;
let GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C;
let GL_MAX_IMAGE_SAMPLES              = 0x906D;
let GL_IMAGE_BINDING_FORMAT           = 0x906E;
let GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7;
let GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8;
let GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9;
let GL_MAX_VERTEX_IMAGE_UNIFORMS      = 0x90CA;
let GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB;
let GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC;
let GL_MAX_GEOMETRY_IMAGE_UNIFORMS    = 0x90CD;
let GL_MAX_FRAGMENT_IMAGE_UNIFORMS    = 0x90CE;
let GL_MAX_COMBINED_IMAGE_UNIFORMS    = 0x90CF;
let GL_COMPRESSED_RGBA_BPTC_UNORM     = 0x8E8C;
let GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 0x8E8D;
let GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 0x8E8E;
let GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 0x8E8F;
let GL_TEXTURE_IMMUTABLE_FORMAT       = 0x912F;
let GL_NUM_SHADING_LANGUAGE_VERSIONS  = 0x82E9;
let GL_VERTEX_ATTRIB_ARRAY_LONG       = 0x874E;
let GL_COMPRESSED_RGB8_ETC2           = 0x9274;
let GL_COMPRESSED_SRGB8_ETC2          = 0x9275;
let GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276;
let GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277;
let GL_COMPRESSED_RGBA8_ETC2_EAC      = 0x9278;
let GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279;
let GL_COMPRESSED_R11_EAC             = 0x9270;
let GL_COMPRESSED_SIGNED_R11_EAC      = 0x9271;
let GL_COMPRESSED_RG11_EAC            = 0x9272;
let GL_COMPRESSED_SIGNED_RG11_EAC     = 0x9273;
let GL_PRIMITIVE_RESTART_FIXED_INDEX  = 0x8D69;
let GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A;
let GL_MAX_ELEMENT_INDEX              = 0x8D6B;
let GL_COMPUTE_SHADER                 = 0x91B9;
let GL_MAX_COMPUTE_UNIFORM_BLOCKS     = 0x91BB;
let GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = 0x91BC;
let GL_MAX_COMPUTE_IMAGE_UNIFORMS     = 0x91BD;
let GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = 0x8262;
let GL_MAX_COMPUTE_UNIFORM_COMPONENTS = 0x8263;
let GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = 0x8264;
let GL_MAX_COMPUTE_ATOMIC_COUNTERS    = 0x8265;
let GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = 0x8266;
let GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS = 0x90EB;
let GL_MAX_COMPUTE_WORK_GROUP_COUNT   = 0x91BE;
let GL_MAX_COMPUTE_WORK_GROUP_SIZE    = 0x91BF;
let GL_COMPUTE_WORK_GROUP_SIZE        = 0x8267;
let GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = 0x90EC;
let GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = 0x90ED;
let GL_DISPATCH_INDIRECT_BUFFER       = 0x90EE;
let GL_DISPATCH_INDIRECT_BUFFER_BINDING = 0x90EF;
let GL_COMPUTE_SHADER_BIT             = 0x00000020;
let GL_DEBUG_OUTPUT_SYNCHRONOUS       = 0x8242;
let GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = 0x8243;
let GL_DEBUG_CALLBACK_FUNCTION        = 0x8244;
let GL_DEBUG_CALLBACK_USER_PARAM      = 0x8245;
let GL_DEBUG_SOURCE_API               = 0x8246;
let GL_DEBUG_SOURCE_WINDOW_SYSTEM     = 0x8247;
let GL_DEBUG_SOURCE_SHADER_COMPILER   = 0x8248;
let GL_DEBUG_SOURCE_THIRD_PARTY       = 0x8249;
let GL_DEBUG_SOURCE_APPLICATION       = 0x824A;
let GL_DEBUG_SOURCE_OTHER             = 0x824B;
let GL_DEBUG_TYPE_ERROR               = 0x824C;
let GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = 0x824D;
let GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR  = 0x824E;
let GL_DEBUG_TYPE_PORTABILITY         = 0x824F;
let GL_DEBUG_TYPE_PERFORMANCE         = 0x8250;
let GL_DEBUG_TYPE_OTHER               = 0x8251;
let GL_MAX_DEBUG_MESSAGE_LENGTH       = 0x9143;
let GL_MAX_DEBUG_LOGGED_MESSAGES      = 0x9144;
let GL_DEBUG_LOGGED_MESSAGES          = 0x9145;
let GL_DEBUG_SEVERITY_HIGH            = 0x9146;
let GL_DEBUG_SEVERITY_MEDIUM          = 0x9147;
let GL_DEBUG_SEVERITY_LOW             = 0x9148;
let GL_DEBUG_TYPE_MARKER              = 0x8268;
let GL_DEBUG_TYPE_PUSH_GROUP          = 0x8269;
let GL_DEBUG_TYPE_POP_GROUP           = 0x826A;
let GL_DEBUG_SEVERITY_NOTIFICATION    = 0x826B;
let GL_MAX_DEBUG_GROUP_STACK_DEPTH    = 0x826C;
let GL_DEBUG_GROUP_STACK_DEPTH        = 0x826D;
let GL_BUFFER                         = 0x82E0;
let GL_SHADER                         = 0x82E1;
let GL_PROGRAM                        = 0x82E2;
let GL_QUERY                          = 0x82E3;
let GL_PROGRAM_PIPELINE               = 0x82E4;
let GL_SAMPLER                        = 0x82E6;
let GL_MAX_LABEL_LENGTH               = 0x82E8;
let GL_DEBUG_OUTPUT                   = 0x92E0;
let GL_CONTEXT_FLAG_DEBUG_BIT         = 0x00000002;
let GL_MAX_UNIFORM_LOCATIONS          = 0x826E;
let GL_FRAMEBUFFER_DEFAULT_WIDTH      = 0x9310;
let GL_FRAMEBUFFER_DEFAULT_HEIGHT     = 0x9311;
let GL_FRAMEBUFFER_DEFAULT_LAYERS     = 0x9312;
let GL_FRAMEBUFFER_DEFAULT_SAMPLES    = 0x9313;
let GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = 0x9314;
let GL_MAX_FRAMEBUFFER_WIDTH          = 0x9315;
let GL_MAX_FRAMEBUFFER_HEIGHT         = 0x9316;
let GL_MAX_FRAMEBUFFER_LAYERS         = 0x9317;
let GL_MAX_FRAMEBUFFER_SAMPLES        = 0x9318;
let GL_INTERNALFORMAT_SUPPORTED       = 0x826F;
let GL_INTERNALFORMAT_PREFERRED       = 0x8270;
let GL_INTERNALFORMAT_RED_SIZE        = 0x8271;
let GL_INTERNALFORMAT_GREEN_SIZE      = 0x8272;
let GL_INTERNALFORMAT_BLUE_SIZE       = 0x8273;
let GL_INTERNALFORMAT_ALPHA_SIZE      = 0x8274;
let GL_INTERNALFORMAT_DEPTH_SIZE      = 0x8275;
let GL_INTERNALFORMAT_STENCIL_SIZE    = 0x8276;
let GL_INTERNALFORMAT_SHARED_SIZE     = 0x8277;
let GL_INTERNALFORMAT_RED_TYPE        = 0x8278;
let GL_INTERNALFORMAT_GREEN_TYPE      = 0x8279;
let GL_INTERNALFORMAT_BLUE_TYPE       = 0x827A;
let GL_INTERNALFORMAT_ALPHA_TYPE      = 0x827B;
let GL_INTERNALFORMAT_DEPTH_TYPE      = 0x827C;
let GL_INTERNALFORMAT_STENCIL_TYPE    = 0x827D;
let GL_MAX_WIDTH                      = 0x827E;
let GL_MAX_HEIGHT                     = 0x827F;
let GL_MAX_DEPTH                      = 0x8280;
let GL_MAX_LAYERS                     = 0x8281;
let GL_MAX_COMBINED_DIMENSIONS        = 0x8282;
let GL_COLOR_COMPONENTS               = 0x8283;
let GL_DEPTH_COMPONENTS               = 0x8284;
let GL_STENCIL_COMPONENTS             = 0x8285;
let GL_COLOR_RENDERABLE               = 0x8286;
let GL_DEPTH_RENDERABLE               = 0x8287;
let GL_STENCIL_RENDERABLE             = 0x8288;
let GL_FRAMEBUFFER_RENDERABLE         = 0x8289;
let GL_FRAMEBUFFER_RENDERABLE_LAYERED = 0x828A;
let GL_FRAMEBUFFER_BLEND              = 0x828B;
let GL_READ_PIXELS                    = 0x828C;
let GL_READ_PIXELS_FORMAT             = 0x828D;
let GL_READ_PIXELS_TYPE               = 0x828E;
let GL_TEXTURE_IMAGE_FORMAT           = 0x828F;
let GL_TEXTURE_IMAGE_TYPE             = 0x8290;
let GL_GET_TEXTURE_IMAGE_FORMAT       = 0x8291;
let GL_GET_TEXTURE_IMAGE_TYPE         = 0x8292;
let GL_MIPMAP                         = 0x8293;
let GL_MANUAL_GENERATE_MIPMAP         = 0x8294;
let GL_AUTO_GENERATE_MIPMAP           = 0x8295;
let GL_COLOR_ENCODING                 = 0x8296;
let GL_SRGB_READ                      = 0x8297;
let GL_SRGB_WRITE                     = 0x8298;
let GL_FILTER                         = 0x829A;
let GL_VERTEX_TEXTURE                 = 0x829B;
let GL_TESS_CONTROL_TEXTURE           = 0x829C;
let GL_TESS_EVALUATION_TEXTURE        = 0x829D;
let GL_GEOMETRY_TEXTURE               = 0x829E;
let GL_FRAGMENT_TEXTURE               = 0x829F;
let GL_COMPUTE_TEXTURE                = 0x82A0;
let GL_TEXTURE_SHADOW                 = 0x82A1;
let GL_TEXTURE_GATHER                 = 0x82A2;
let GL_TEXTURE_GATHER_SHADOW          = 0x82A3;
let GL_SHADER_IMAGE_LOAD              = 0x82A4;
let GL_SHADER_IMAGE_STORE             = 0x82A5;
let GL_SHADER_IMAGE_ATOMIC            = 0x82A6;
let GL_IMAGE_TEXEL_SIZE               = 0x82A7;
let GL_IMAGE_COMPATIBILITY_CLASS      = 0x82A8;
let GL_IMAGE_PIXEL_FORMAT             = 0x82A9;
let GL_IMAGE_PIXEL_TYPE               = 0x82AA;
let GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = 0x82AC;
let GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = 0x82AD;
let GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = 0x82AE;
let GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = 0x82AF;
let GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = 0x82B1;
let GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = 0x82B2;
let GL_TEXTURE_COMPRESSED_BLOCK_SIZE  = 0x82B3;
let GL_CLEAR_BUFFER                   = 0x82B4;
let GL_TEXTURE_VIEW                   = 0x82B5;
let GL_VIEW_COMPATIBILITY_CLASS       = 0x82B6;
let GL_FULL_SUPPORT                   = 0x82B7;
let GL_CAVEAT_SUPPORT                 = 0x82B8;
let GL_IMAGE_CLASS_4_X_32             = 0x82B9;
let GL_IMAGE_CLASS_2_X_32             = 0x82BA;
let GL_IMAGE_CLASS_1_X_32             = 0x82BB;
let GL_IMAGE_CLASS_4_X_16             = 0x82BC;
let GL_IMAGE_CLASS_2_X_16             = 0x82BD;
let GL_IMAGE_CLASS_1_X_16             = 0x82BE;
let GL_IMAGE_CLASS_4_X_8              = 0x82BF;
let GL_IMAGE_CLASS_2_X_8              = 0x82C0;
let GL_IMAGE_CLASS_1_X_8              = 0x82C1;
let GL_IMAGE_CLASS_11_11_10           = 0x82C2;
let GL_IMAGE_CLASS_10_10_10_2         = 0x82C3;
let GL_VIEW_CLASS_128_BITS            = 0x82C4;
let GL_VIEW_CLASS_96_BITS             = 0x82C5;
let GL_VIEW_CLASS_64_BITS             = 0x82C6;
let GL_VIEW_CLASS_48_BITS             = 0x82C7;
let GL_VIEW_CLASS_32_BITS             = 0x82C8;
let GL_VIEW_CLASS_24_BITS             = 0x82C9;
let GL_VIEW_CLASS_16_BITS             = 0x82CA;
let GL_VIEW_CLASS_8_BITS              = 0x82CB;
let GL_VIEW_CLASS_S3TC_DXT1_RGB       = 0x82CC;
let GL_VIEW_CLASS_S3TC_DXT1_RGBA      = 0x82CD;
let GL_VIEW_CLASS_S3TC_DXT3_RGBA      = 0x82CE;
let GL_VIEW_CLASS_S3TC_DXT5_RGBA      = 0x82CF;
let GL_VIEW_CLASS_RGTC1_RED           = 0x82D0;
let GL_VIEW_CLASS_RGTC2_RG            = 0x82D1;
let GL_VIEW_CLASS_BPTC_UNORM          = 0x82D2;
let GL_VIEW_CLASS_BPTC_FLOAT          = 0x82D3;
let GL_UNIFORM                        = 0x92E1;
let GL_UNIFORM_BLOCK                  = 0x92E2;
let GL_PROGRAM_INPUT                  = 0x92E3;
let GL_PROGRAM_OUTPUT                 = 0x92E4;
let GL_BUFFER_VARIABLE                = 0x92E5;
let GL_SHADER_STORAGE_BLOCK           = 0x92E6;
let GL_VERTEX_SUBROUTINE              = 0x92E8;
let GL_TESS_CONTROL_SUBROUTINE        = 0x92E9;
let GL_TESS_EVALUATION_SUBROUTINE     = 0x92EA;
let GL_GEOMETRY_SUBROUTINE            = 0x92EB;
let GL_FRAGMENT_SUBROUTINE            = 0x92EC;
let GL_COMPUTE_SUBROUTINE             = 0x92ED;
let GL_VERTEX_SUBROUTINE_UNIFORM      = 0x92EE;
let GL_TESS_CONTROL_SUBROUTINE_UNIFORM = 0x92EF;
let GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = 0x92F0;
let GL_GEOMETRY_SUBROUTINE_UNIFORM    = 0x92F1;
let GL_FRAGMENT_SUBROUTINE_UNIFORM    = 0x92F2;
let GL_COMPUTE_SUBROUTINE_UNIFORM     = 0x92F3;
let GL_TRANSFORM_FEEDBACK_VARYING     = 0x92F4;
let GL_ACTIVE_RESOURCES               = 0x92F5;
let GL_MAX_NAME_LENGTH                = 0x92F6;
let GL_MAX_NUM_ACTIVE_VARIABLES       = 0x92F7;
let GL_MAX_NUM_COMPATIBLE_SUBROUTINES = 0x92F8;
let GL_NAME_LENGTH                    = 0x92F9;
let GL_TYPE                           = 0x92FA;
let GL_ARRAY_SIZE                     = 0x92FB;
let GL_OFFSET                         = 0x92FC;
let GL_BLOCK_INDEX                    = 0x92FD;
let GL_ARRAY_STRIDE                   = 0x92FE;
let GL_MATRIX_STRIDE                  = 0x92FF;
let GL_IS_ROW_MAJOR                   = 0x9300;
let GL_ATOMIC_COUNTER_BUFFER_INDEX    = 0x9301;
let GL_BUFFER_BINDING                 = 0x9302;
let GL_BUFFER_DATA_SIZE               = 0x9303;
let GL_NUM_ACTIVE_VARIABLES           = 0x9304;
let GL_ACTIVE_VARIABLES               = 0x9305;
let GL_REFERENCED_BY_VERTEX_SHADER    = 0x9306;
let GL_REFERENCED_BY_TESS_CONTROL_SHADER = 0x9307;
let GL_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x9308;
let GL_REFERENCED_BY_GEOMETRY_SHADER  = 0x9309;
let GL_REFERENCED_BY_FRAGMENT_SHADER  = 0x930A;
let GL_REFERENCED_BY_COMPUTE_SHADER   = 0x930B;
let GL_TOP_LEVEL_ARRAY_SIZE           = 0x930C;
let GL_TOP_LEVEL_ARRAY_STRIDE         = 0x930D;
let GL_LOCATION                       = 0x930E;
let GL_LOCATION_INDEX                 = 0x930F;
let GL_IS_PER_PATCH                   = 0x92E7;
let GL_SHADER_STORAGE_BUFFER          = 0x90D2;
let GL_SHADER_STORAGE_BUFFER_BINDING  = 0x90D3;
let GL_SHADER_STORAGE_BUFFER_START    = 0x90D4;
let GL_SHADER_STORAGE_BUFFER_SIZE     = 0x90D5;
let GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = 0x90D6;
let GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = 0x90D7;
let GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = 0x90D8;
let GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = 0x90D9;
let GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = 0x90DA;
let GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 0x90DB;
let GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = 0x90DC;
let GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = 0x90DD;
let GL_MAX_SHADER_STORAGE_BLOCK_SIZE  = 0x90DE;
let GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = 0x90DF;
let GL_SHADER_STORAGE_BARRIER_BIT     = 0x00002000;
let GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = 0x8F39;
let GL_DEPTH_STENCIL_TEXTURE_MODE     = 0x90EA;
let GL_TEXTURE_BUFFER_OFFSET          = 0x919D;
let GL_TEXTURE_BUFFER_SIZE            = 0x919E;
let GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = 0x919F;
let GL_TEXTURE_VIEW_MIN_LEVEL         = 0x82DB;
let GL_TEXTURE_VIEW_NUM_LEVELS        = 0x82DC;
let GL_TEXTURE_VIEW_MIN_LAYER         = 0x82DD;
let GL_TEXTURE_VIEW_NUM_LAYERS        = 0x82DE;
let GL_TEXTURE_IMMUTABLE_LEVELS       = 0x82DF;
let GL_VERTEX_ATTRIB_BINDING          = 0x82D4;
let GL_VERTEX_ATTRIB_RELATIVE_OFFSET  = 0x82D5;
let GL_VERTEX_BINDING_DIVISOR         = 0x82D6;
let GL_VERTEX_BINDING_OFFSET          = 0x82D7;
let GL_VERTEX_BINDING_STRIDE          = 0x82D8;
let GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D9;
let GL_MAX_VERTEX_ATTRIB_BINDINGS     = 0x82DA;
let GL_VERTEX_BINDING_BUFFER          = 0x8F4F;
let GL_MAX_VERTEX_ATTRIB_STRIDE       = 0x82E5;
let GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = 0x8221;
let GL_TEXTURE_BUFFER_BINDING         = 0x8C2A;
let GL_MAP_PERSISTENT_BIT             = 0x0040;
let GL_MAP_COHERENT_BIT               = 0x0080;
let GL_DYNAMIC_STORAGE_BIT            = 0x0100;
let GL_CLIENT_STORAGE_BIT             = 0x0200;
let GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000;
let GL_BUFFER_IMMUTABLE_STORAGE       = 0x821F;
let GL_BUFFER_STORAGE_FLAGS           = 0x8220;
let GL_CLEAR_TEXTURE                  = 0x9365;
let GL_LOCATION_COMPONENT             = 0x934A;
let GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = 0x934B;
let GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = 0x934C;
let GL_QUERY_BUFFER                   = 0x9192;
let GL_QUERY_BUFFER_BARRIER_BIT       = 0x00008000;
let GL_QUERY_BUFFER_BINDING           = 0x9193;
let GL_QUERY_RESULT_NO_WAIT           = 0x9194;
let GL_MIRROR_CLAMP_TO_EDGE           = 0x8743;
let GL_CONTEXT_LOST                   = 0x0507;
let GL_NEGATIVE_ONE_TO_ONE            = 0x935E;
let GL_ZERO_TO_ONE                    = 0x935F;
let GL_CLIP_ORIGIN                    = 0x935C;
let GL_CLIP_DEPTH_MODE                = 0x935D;
let GL_QUERY_WAIT_INVERTED            = 0x8E17;
let GL_QUERY_NO_WAIT_INVERTED         = 0x8E18;
let GL_QUERY_BY_REGION_WAIT_INVERTED  = 0x8E19;
let GL_QUERY_BY_REGION_NO_WAIT_INVERTED = 0x8E1A;
let GL_MAX_CULL_DISTANCES             = 0x82F9;
let GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = 0x82FA;
let GL_TEXTURE_TARGET                 = 0x1006;
let GL_QUERY_TARGET                   = 0x82EA;
let GL_GUILTY_CONTEXT_RESET           = 0x8253;
let GL_INNOCENT_CONTEXT_RESET         = 0x8254;
let GL_UNKNOWN_CONTEXT_RESET          = 0x8255;
let GL_RESET_NOTIFICATION_STRATEGY    = 0x8256;
let GL_LOSE_CONTEXT_ON_RESET          = 0x8252;
let GL_NO_RESET_NOTIFICATION          = 0x8261;
let GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT = 0x00000004;
let GL_CONTEXT_RELEASE_BEHAVIOR       = 0x82FB;
let GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x82FC;
let GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB   = 0x8242;
let GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = 0x8243;
let GL_DEBUG_CALLBACK_FUNCTION_ARB    = 0x8244;
let GL_DEBUG_CALLBACK_USER_PARAM_ARB  = 0x8245;
let GL_DEBUG_SOURCE_API_ARB           = 0x8246;
let GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB = 0x8247;
let GL_DEBUG_SOURCE_SHADER_COMPILER_ARB = 0x8248;
let GL_DEBUG_SOURCE_THIRD_PARTY_ARB   = 0x8249;
let GL_DEBUG_SOURCE_APPLICATION_ARB   = 0x824A;
let GL_DEBUG_SOURCE_OTHER_ARB         = 0x824B;
let GL_DEBUG_TYPE_ERROR_ARB           = 0x824C;
let GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = 0x824D;
let GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = 0x824E;
let GL_DEBUG_TYPE_PORTABILITY_ARB     = 0x824F;
let GL_DEBUG_TYPE_PERFORMANCE_ARB     = 0x8250;
let GL_DEBUG_TYPE_OTHER_ARB           = 0x8251;
let GL_MAX_DEBUG_MESSAGE_LENGTH_ARB   = 0x9143;
let GL_MAX_DEBUG_LOGGED_MESSAGES_ARB  = 0x9144;
let GL_DEBUG_LOGGED_MESSAGES_ARB      = 0x9145;
let GL_DEBUG_SEVERITY_HIGH_ARB        = 0x9146;
let GL_DEBUG_SEVERITY_MEDIUM_ARB      = 0x9147;
let GL_DEBUG_SEVERITY_LOW_ARB         = 0x9148;
let GL_SHADER_BINARY_FORMAT_SPIR_V    = 0x9551;
let GL_SPIR_V_BINARY                  = 0x9552;
let GL_PARAMETER_BUFFER               = 0x80EE;
let GL_PARAMETER_BUFFER_BINDING       = 0x80EF;
let GL_CONTEXT_FLAG_NO_ERROR_BIT      = 0x00000008;
let GL_VERTICES_SUBMITTED             = 0x82EE;
let GL_PRIMITIVES_SUBMITTED           = 0x82EF;
let GL_VERTEX_SHADER_INVOCATIONS      = 0x82F0;
let GL_TESS_CONTROL_SHADER_PATCHES    = 0x82F1;
let GL_TESS_EVALUATION_SHADER_INVOCATIONS = 0x82F2;
let GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED = 0x82F3;
let GL_FRAGMENT_SHADER_INVOCATIONS    = 0x82F4;
let GL_COMPUTE_SHADER_INVOCATIONS     = 0x82F5;
let GL_CLIPPING_INPUT_PRIMITIVES      = 0x82F6;
let GL_CLIPPING_OUTPUT_PRIMITIVES     = 0x82F7;
let GL_POLYGON_OFFSET_CLAMP           = 0x8E1B;
let GL_SPIR_V_EXTENSIONS              = 0x9553;
let GL_NUM_SPIR_V_EXTENSIONS          = 0x9554;
let GL_TEXTURE_MAX_ANISOTROPY         = 0x84FE;
let GL_MAX_TEXTURE_MAX_ANISOTROPY     = 0x84FF;
let GL_TRANSFORM_FEEDBACK_OVERFLOW    = 0x82EC;
let GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW = 0x82ED;
