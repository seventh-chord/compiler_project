
extern "kernel32.lib" {
    fn ExitProcess(exit_code: u32);
    fn GetStdHandle(key: u32) -> u64;
    fn WriteFile(file: u64, buffer: *u8, length: u32, written: *u32, overlapped: *void);
}

fn c_string_length(string: *u8) -> i64 {
    let length = 0;
    for (*string != 0) {
        string += 1;
        length += 1;
    }
    return length;
}

fn print(string: *u8) {
    let length = c_string_length(string);
    let written: u32;
    let stdout_handle = GetStdHandle(u32(-11));
    WriteFile(stdout_handle, string, u32(length), &written, null);
}

fn assert(condition: bool, message: *u8) {
    if (!condition) {
        print("Assertion failed: ");
        print(message);
        print("\n");
        ExitProcess(-1);
    }
}

fn main() {
    print("In Marco Polos descriptions the Kahn discovered...\n");

    let three = other(1, 2);
    let b = three == 3;
    assert(b, "Math is broken");

    wont_work_for_now();

    more_breakage_incomming();

    assert(true, "This should NOT assert");
    assert(false, "This should assert");
}

fn other(a, b: u32) -> u32 {
    big_function();
    return a + b;
}

fn big_function() {
    let a: u64 = 1;
    let b: u64;

    a = 3 + 5;
    b = a;
    a = 4 + a;

    let p = &a;
    *p = a + 7;

    *p = 2 + *p;

    let big: [10]u16;
    big[0] = 0x48;
    big[1] = 0x8d;

    let big_p = &big;
    big_p[1] = 0x8d;

    big_p[b] = 0xf0;


    let matrix: [4][4]u32;

    let i = 3;
    let j = 3;
    matrix[i][j] = 1;

    let thing = Foo { 3, 2 };

    thing = Foo { a: u64(thing.b), b: u8(thing.a) };

    let thinger = &thing;
    thinger.b = 2;


    let dude: [2]Foo;
    dude[1] = thing;
}

struct Foo {
    a: u64;
    b: u8;
}


fn a() -> i64 {
    return -24;
}

fn big_a(b, c: i64) {}

fn wont_work_for_now() {
    let b = a() + a() + a();
    let c = 2 * 12 * 3;

    if (b == -c) {
        print("Nice\n");
    } else {
        print("Something is borked\n");
    }


    let m = 0;
    let n = &m;
    *n = a();

    let along_the_road = Another_Town { a(), a() }; 
    build(along_the_road);

    big_a(a(), a());

    /*
    let array: [3]i64;
    let pointer = &array;
    c = pointer[0];
    */
}

struct Another_Town { a, b: i64; }

fn build(town: Another_Town) {
    town.a = 1;
}


fn more_breakage_incomming() {
    let capacity = Cloud { 5, 10 }.capacity;
    assert(capacity == 10, "It didn't work after all :(\n");

    capacity = modernize().capacity;
    assert(capacity == 20, "I really hope this doesn't assert\n");

    let other_cloud: Cloud;
    upgrade(&other_cloud);
    assert(other_cloud.capacity == 1, "My cloud didn't grow\n");

    let new_capacity = upgrade(&other_cloud).capacity;
    assert(new_capacity == 2, "All the cloud rained away\n");
}

fn upgrade(cloud: *Cloud) -> *Cloud {
    cloud.capacity += 1;
    return cloud;
}

fn modernize() -> Cloud {
    let shiny_new_thing = Cloud { length: 10, capacity: 20 };
    return shiny_new_thing;
}

struct Cloud {
    length: i32;
    capacity: i32;
}
