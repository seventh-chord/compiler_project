
extern "kernel32.lib" {
    fn ExitProcess(exit_code: u32);
    fn GetStdHandle(key: u32) -> u64;
    fn WriteFile(file: u64, buffer: *u8, length: u32, written: *u32, overlapped: *void);
}

fn print(string: String) {
    let written: u32;
    let stdout_handle = GetStdHandle(u32(-11));
    WriteFile(stdout_handle, string.data, u32(string.length), &written, null);
}

fn assert(condition: bool, message: String) {
    if (!condition) {
        print("Assertion failed: ");
        print(message);
        print("\n");
        ExitProcess(-1);
    }
}

fn main() {
    pointer_arithmetic();

    print("In Marco Polos descriptions the Kahn discovered...\n");

    let three = other(1, 2);
    let b = u32('0') + three == u32('3');
    assert(b, "Math is broken");

    wont_work_for_now();

    more_breakage_incomming();

    big_bummer();

    assert(enum_length(Type_Kind) == i64(Type_Kind::ENUM) + 1, "There are not enough types!");

    //print(get_second_word("Hello there dude"));

    assert(true, "This should NOT assert");
    assert(false, "This should assert");
}

fn other(a, b: u32) -> u32 {
    big_function();
    return a + b;
}

fn big_function() {
    let a: u64 = 1;
    let b: u64;

    a = 3 + 5;
    b = a;
    a = 4 + a;

    let p = &a;
    *p = a + 7;

    *p = 2 + *p;

    let big: [10]u16;
    big[0] = 0x48;
    big[1] = 0x8d;

    let big_p = &big;
    big_p[1] = 0x8d;

    big_p[b] = 0xf0;


    let matrix: [4][4]u32;

    let i = 3;
    let j = 3;
    matrix[i][j] = 1;

    let thing = Foo { 3, 2 };

    thing = Foo { a: u64(thing.b), b: u8(thing.a) };

    let thinger = &thing;
    thinger.b = 2;


    let dude: [2]Foo;
    dude[1] = thing;
}

struct Foo {
    a: u64;
    b: u8;
}


fn a() -> i64 {
    return -24;
}

fn big_a(b, c: i64) {}

fn wont_work_for_now() {
    let b = a() + a() + a();
    let c = 2 * 12 * 3;

    if (b == -c) {
        print("Nice\n");
    } else {
        print("Something is borked\n");
    }


    let m = 0;
    let n = &m;
    *n = a();

    let along_the_road = Another_Town { a(), a() }; 
    build(along_the_road);

    big_a(a(), a());

    /*
    let array: [3]i64;
    let pointer = &array;
    c = pointer[0];
    */
}

struct Another_Town { a, b: i64; }

fn build(town: Another_Town) {
    assert(town.a == town.b, "Broken? Yeah\n");

    town.a = 1;

    let t: Type_Kind;

    t = type_info_of_value(town);
    assert(t == Type_Kind::STRUCT, "Darn this is no good\n");

    t = type_info_of_type(Another_Town);
    assert(t == Type_Kind::STRUCT, "At least this works as intended\n");
}


fn more_breakage_incomming() {
    let capacity = Cloud { 5, 10 }.capacity;
    assert(capacity == 10, "It didn't work after all :(\n");

    capacity = modernize().capacity;
    assert(capacity == 20, "I really hope this doesn't assert\n");

    let other_cloud: Cloud;
    upgrade(&other_cloud);
    assert(other_cloud.capacity == 1, "My cloud didn't grow\n");
    let newer_capacity = upgrade_by_value(other_cloud).capacity;
    assert(newer_capacity == 2, "Didn't grow again, darn\n");
    assert(other_cloud.capacity == 1, "Still works here though\n");

    let new_capacity = upgrade(&other_cloud).capacity;
    assert(new_capacity == 2, "All the cloud rained away\n");

    assert(will_it_crash_though().a == 1, "It did crash, though!\n");
}

fn upgrade(cloud: *Cloud) -> *Cloud {
    cloud.capacity += 1;
    return cloud;
}

fn upgrade_by_value(cloud: Cloud) -> Cloud {
    cloud.capacity += 1;
    return cloud;
}

fn modernize() -> Cloud {
    let shiny_new_thing = Cloud { length: 10, capacity: 20 };
    return shiny_new_thing;
}

// Note that this struct is 64 bits large, and that it thus fits in a register
struct Cloud {
    length: i32;
    capacity: i32;
}

struct Bigger_Struct { a, b, c: i64; } // This won't fit in a register

fn will_it_crash_though() -> Bigger_Struct {
    return { 1, 2, 3 };
}


fn the_stage_will_collapse() -> i64 {
    let n = 9 + (9 + (9 + (9 + (9))));
    return 2;
}
fn big_bummer() {
    let a = (1 + (1 + (1 + (1 + the_stage_will_collapse()))));
    assert(a == 6, "Big bummer\n");
}


fn pointer_arithmetic() {
    let array: [10]u32;
    let a = &array[0];
    let b = 9 + a;

    let distance = b - a;
    assert(distance == 9, "Hmm, thats not how division works\n");

    empty_structs_should_work({});
}

struct Empty {}

fn empty_structs_should_work(e: Empty) {
    let q = e;
    let r = &q;

    let n = r - r;
}


/*
fn get_second_word(string: String) -> String {
    let result: String;

    let i = 0;
    for (i < string.length) {
        result.length += 1;
        if (string[i] == ' ') {
            if (result.data == null) {
                result.data = string.data + i + 1;
                result.length = 0;
            } else {
                break;
            }
        }
        i += 1;
    }

    return result;
}
*/
