
extern "kernel32.lib" {
    fn ExitProcess(exit_code: u32);
    fn GetStdHandle(key: u32) -> u64;
    fn WriteFile(file: u64, buffer: *u8, length: u32, written: *u32, overlapped: *void);
}

typedef WriteFile_Type = *fn(file: u64, buffer: *u8, length: u32, written: *u32, overlapped: *void);
let write_fn: WriteFile_Type = &WriteFile;

let stdout_handle = GetStdHandle(u32(-11));
fn print(string: String) {
    let written: u32;
    write_fn(stdout_handle, string.data, u32(string.length), &written, null);
}


typedef int = i32;

fn main() {
    let n: i32 = 7;

    let other: *fn(p: i32) -> i32;
    other = &my_callback;

    n = other(n);

    n = give_us_a_function_pointer()(n);

    n = down_the_rabbit_hole()()(n);

    if (n != 10) {
        print("The callback DID NOT WORK\n");
    } else {
        print("The callback did work\n");
    }

    print_keyword();

    ExitProcess(0);
}

fn my_callback(parameter: i32) -> i32 {
    print("You just called my callback!\n");
    return parameter + 1;
}

fn give_us_a_function_pointer() -> *fn(p: i32) -> i32 {
    return &my_callback;
}

fn down_the_rabbit_hole() -> *fn() -> *fn(p: i32) -> int {
    return &give_us_a_function_pointer;
}


typedef Keyword_Factory = *fn() -> String;

fn get_keyword() -> String {
    return "Big bummer";
}

fn get_keyword_factory() -> Keyword_Factory {
    return &get_keyword;
}

fn print_keyword() {
    let factory = get_keyword_factory();
    let keyword = factory();

    print(keyword);
    print("\n");
}
