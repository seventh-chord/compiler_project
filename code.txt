
fn swanky() -> u8 {
    var x: u8 = 14;
    var array: [3]u8 = [3]u8 { 2, 1, 3 };
    array = [3]u8 { 0, 0, array[1] + x };
    output = array[2];
}

fn remove_fifteen(p: 'u8) {
    var fifteen: u8 = swanky();
    'p = 'p - fifteen;
}

fn bar(a: u8, b: u8) -> u8 {
    var dingus: u64 = 1;
    dingus = dingus + u64(1 + u8(2));

    output = a + b*2 + u8(dingus);
}

fn foo(a: u8) -> u8 {
    var five: u8 = 20;
    remove_fifteen(@five);

    output = a*five + (255 + 1);
}

fn main() -> u8 {
    var x: u8 = bar(1, 0) + foo(4*3 - 3*(1 + 2));

    x = 2*(20 + 10) - x*2;

    var y: u8 = x - 2 + 3;
    var z: u8 = y + 2 + 3;
    var w: u8 = z;
    w = 1 + w;
    output = w + 45 + (255 + 1);
}

# "long" term
#   calling external functions
#   .pdata so we can crash properly, or whatever that is for
#   conditionals
#   global variables
#   constants
#   structs, unions, enums
#   size_of, align_of, type_of
#   bitwise operators (<< >> | & ~ ^)
#   hex literals
#   debug info
#   growing the stack? stack guards?
#   type inference
#   constant evaluation / elimination
#   peephole optimizer
